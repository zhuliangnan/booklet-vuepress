## 日志系统：一条SQL更新语句是如何执行的？

::: tip
 一条Sql更新是如何执行的呢，查询语句的那一套流程，更新语句也是同样会走一遍。
::: 
```sql
mysql> update T set c=c+1 where ID=2;
```
::: tip
 你执行语句前要先连接数据库，这是`连接器`的工作。

 前面我们说过，在一个表上有更新的时候，跟这个表有关的`查询缓存会失效`，所以这条语句就会把表上所有`缓存结果`都清空。这也就是我们一般不建议使用查询缓存的原因。

 接下来，`分析器`会通过`词法和语法解析`知道这是一条更新语句。

 `优化器`决定要使用 ID 这个索引。然后，执行器负责具体`执行`，找到这一行，`然后更新`。
::: 
与查询流程不一样的是，更新流程还涉及两个重要的日志模块，`redo log（重做日志`）和 `binlog（归档日志）`

binlog是默认关闭的，打开才会有binlog

### 重要的日志模块：redo log
::: tip
 具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 `redo log` 里面，`并更新内存`，这个时候`更新就算完成`了。

 同时，`InnoDB 引擎`会在`适当`的时候，将这个操作记录`更新到磁盘`里面，而这个更新往往是在`系统比较空闲`的时候做.

 `redo log` 是循环写的，`空间固定会用完，满了就先写到磁盘`
::: 

::: tip
 比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么这块总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。
::: 
![img](/mysql/base/16a7950217b3f0f4ed02db5db59562a7.png)
::: tip
 `write pos` 是当前记录的位置，`check point`记录的是上次刷盘的位置，如果write pos `快要追上` check point ，代表内存快`写满`了，脏页很多，需要强制刷盘
::: 
有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 `crash-safe`。

好比数据库`重启`了，内存中的`数据页没有同步到磁盘`中，可以通过redo log日志恢复



### 重要的日志模块：binlog
::: tip
 为什么会有两份日志？

 因为最开始 MySQL 里并没有 `InnoDB` 引擎。

 MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 `crash-safe` 的能力，`binlog` 日志只能用于`归档`。

 而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统——也就是 `redo log` 来实现 crash-safe 能力。
::: 
- `redo log 是 InnoDB 引擎特有的`；binlog 是 MySQL 的 `Server 层`实现的，所有引擎都可以使用。

- redo log 是`物理日志`，记录的是“在`某个数据页上做了什么修改`”；`binlog` 是`逻辑日志`，记录的是这个`语句的原始逻辑`，比如“给 ID=2 这一行的 c 字段加 1 ”。

- `redo log 是循环写的`，空间固定会用完；`binlog` 是可以`追加写入的`。“追加写”是指 `binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志`。

  下面我们来看一下下面这个语句的执行过程

```sql
mysql> update T set c=c+1 where ID=2;
```

1. 执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。
2. 执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口`写入`这行新数据。
3. 引擎将这行新数据`更新到内存`中，同时将这个更新操作记录到` redo log` 里面，此时 redo log 处于 `prepare 状态`。然后`告知执行器执行完成了，随时可以提交事务`。
4. `执行器生成这个操作的 binlog`，并把 binlog `写入磁盘`。执行器调用引擎的提交事务接口，引擎把刚刚写入的 `redo log 改成提交（commit）状态，更新完成`。
::: tip
 简单的说--对数据操作的行为（加减），由「执行器」完成；对数据读取行为，由「引擎」完成。
::: 
图中浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。

![img](/mysql/base/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png)
::: tip
 最后三步看上去有点“绕”，将 redo log 的写入拆成了两个步骤：prepare 和 commit，这就是"`两阶段提交`"。
::: 
### 两阶段提交
::: tip
 为什么必须有“`两阶段提交`”呢？这是为了让两份日志之间的逻辑一致。要说明这个问题

 我们得从一个问题说起：`怎样让数据库恢复到半个月内任意一秒的状态？`
::: 
当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做：

1. 首先，找到最近的一次`全量备份(整库备份)`，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到`临时库`；
2. 然后，从备份的时间点开始，将备份的 `binlog 依次取出来，重放到中午误删表之前的那个时刻`;

由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完 redo log 再写 binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。

#### 先写 redo log 后写 binlog
::: tip
  先写 redo log 后写 binlog。
 
  假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，`系统即使崩溃，仍然能够把数据恢复回来`，所以恢复后这一行 c 的值是 1。但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。然后你会发现，`如果需要用这个 binlog 来恢复临时库的话`，由于这个语句的 `binlog 丢失`，这个临时库就会`少了这一次更新`，恢复出来的这一行 c 的值就是 0，`与原库的值不同`。
::: 
#### 先写 binlog 后写 redo log
::: tip
  先写 binlog 后写 redo log。
 
  如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个`事务`无效，所以这一行 c 的值是 0。
 
  但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。
 
  所以，`在之后用 binlog 来恢复的时候就多了一个事务出来`，恢复出来的这一行 c 的值就是 1，与原库的值不同。
::: 

::: tip
 总结：

 本质上是因为 `redo log 负责事务`； `binlog负责归档恢复`； 各司其职，相互配合，才提供(保证)了现有功能的完整性；
::: 
`nnodb_flush_log_at_trx_commit` 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘，这样可以保证 MySQL 异常重启之后 数据不丢失。

`sync_binlog` 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数也建议你设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。