## 深入浅出索引二

### 索引的执行案例分析

```sql
mysql> create table T (
ID int primary key,
k int NOT NULL DEFAULT 0, 
s varchar(16) NOT NULL DEFAULT '',
index k(k))
engine=InnoDB;

insert into T values(100,1, 'aa'),(200,2,'bb'),(300,3,'cc'),(500,5,'ee'),(600,6,'ff'),(700,7,'gg');
```

![img](/mysql/base/dcda101051f28502bd5c4402b292e38d-16375577920781.png)

**如果我执行 `select * from T where k between 3 and 5`，需要执行几次树的搜索操作，会扫描多少行？**

执行流程如下：

1. 在 k 索引树上找到 k=3 的记录，取得 ID = 300；
2. 再到 ID 索引树查到 ID=300 对应的 R3；
3. 在 k 索引树取下一个值 k=5，取得 ID=500；
4. 再回到 ID 索引树查到 ID=500 对应的 R4；
5. 在 k 索引树取下一个值 k=6，不满足条件，循环结束。

在这个过程中，`回到主键索引树搜索的过程，我们称为回表`。可以看到，这个查询过程读了 k 索引树的 3 条记录（步骤 1、3 和 5），回表了两次（步骤 2 和 4）。
::: tip
 注意： 其实它读到5之后，还需要再读取下一个的值，判断是否满足条件，如果不满足，才真正结束循环，所以需要读取三条记录
::: 
### 覆盖索引
::: tip
 覆盖索引：

 二级索引覆盖到了所有的查询字段, 此时不需要回表查主键索引
::: 
例如以下语句就不需要进行回表,仅仅查询id

```sql
select ID from T where k between 3 and 5
```
::: tip
 由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的`性能优化手段`。
::: 


**那么基于上面，在一个市民信息表上，是否有必要将`身份证号`和`名字`建立联合索引？**

一般来说，我们只要在身份证号字段上建立索引就够了。而再建立一个（身份证号、姓名）的联合索引，是不是浪费空间？

如果现在有一个高频请求，`要根据市民的身份证号查询他的姓名`，这个联合索引就有意义了。它可以在这个高频请求上用到`覆盖索引`，不再需要回表查整行记录，减少语句的执行时间。

### 最左前缀原则

为了直观地说明这个概念，我们用（name，age）这个联合索引来分析。

![img](/mysql/base/89f74c631110cfbc83298ef27dcd6370.jpg)

可以看到`索引项`是按照索引定义里面出现的`字段顺序排序的`。

当你的逻辑需求是查到所有名字是“张三”的人时，可以快速定位到 ID4，然后向后遍历得到所有需要的结果。

如果你要查的是所有名字第一个字是“张”的人，你的 SQL 语句的条件是"where name like ‘张 %’"。这时，你也能够用上这个索引，查找到第一个符合条件的记录是 ID3，然后向后遍历，直到不满足条件为止。

可以看到只要`满足最左前缀`，就可以利用索引来`加速检索`

#### 如何安排索引内的字段顺序。
::: tip
 第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要`优先考虑`采用的。

 第二原则是，在确定了所需要的索引之后，尽量让长字段减少创建次数，避免浪费空间
::: 
比如说我们要查询b，a+b ， 可以设置 （b,a）的组合索引。

再比如我们要创建 (a,b)、(b) 还是 (b,a)、(a)？考虑空间，字段长的只建立一次，短的建立两次。

### 索引下推

最左前缀可以用于在索引中定位记录。这时，那些不符合最左前缀的部分，会怎么样呢？

以市民表的联合索引`（name, age）`为例

如果现在有一个需求：检索出表中“`名字第一个字是张，而且年龄是10岁的所有男孩`”。那么，SQL 语句是这么写的：

```sql
mysql select * from tuser where name like '张%' and age=10 and ismale=1;
```
::: tip
 首先找到第一个满足条件的记录 ID3。当然，这还不错，总比全表扫描要好。

 然后我们需要判断其他条件是否满足。

 在` MySQL 5.6 `之前，只能从 ID3 开始一个个回表。到主键索引上找出数据行，再对比字段值。

 而 MySQL 5.6 引入的`索引下推优化（index condition pushdown)`， 可以在索引遍历过程中，对索引中`包含的字段`先做`判断`，直接`过滤`掉`不满足条件`的记录，`减少回表`次数。
::: 
下面两张图是无索引下推和有索引下推

**无索引下推执行流程**

![img](/mysql/base/b32aa8b1f75611e0759e52f5915539ac.jpg)

**有索引下推执行流程**

![img](/mysql/base/76e385f3df5a694cc4238c7b65acfe1b.jpg)
::: tip
 索引下推可以帮我们先去过滤掉一部分条件，减少回表次数。
::: 
::: tip
 提问：以下的索引那个可以删除
::: 
```sql
CREATE TABLE `geek` (
  `a` int(11) NOT NULL,
  `b` int(11) NOT NULL,
  `c` int(11) NOT NULL,
  `d` int(11) NOT NULL,
  PRIMARY KEY (`a`,`b`),
  KEY `c` (`c`),
  KEY `ca` (`c`,`a`),
  KEY `cb` (`c`,`b`)
) ENGINE=InnoDB;
```

答：

当（a,b）为主键，增加c为索引，由于是先普通索引然后主键索引，所以可以堪称（c,a,b） 根据左前缀来看。就是c|c,a|c,a,b| 这三种。

由此（c,a）没必要重复设定为索引。设定（c,b）是有意义的