## 深入浅出索引一

### 索引的常见模型
::: tip
 三种常见、也比较简单的数据结构，它们分别是哈希表、有序数组和搜索树。

 对于哈希表来说：

 查找速度还可以，对于冲突我们还可以使用拉链法解决，但是涉及区间查找就真的gg了

 所以哈希表这种结构适用于只有等值查询的场景

 对于数组来说：

 查找和区间查找是可以用二分法O(log(N))，仅仅看查询是最快的了

 但是插入数据就gg了，需要移动了元素太多，内存消耗太大
::: 


### 数据库索引的原理，为什么要用 B+树，为什么不用二叉树？

可以从几个维度去看这个问题，**查询是否够快**，**效率是否稳定**，**存储数据多少**，**以及查找磁盘次数，**为什么不是二叉树，为什么不是平衡二叉树，为什么不是B树，而偏偏是B+树呢？
::: tip
 **为什么不是一般二叉树？**
::: 
如果二叉树特殊化为一个`链表`，相当于`全表扫描`
::: tip
 **为什么不是平衡二叉树呢？**
::: 
在内存比在磁盘的数据，查询效率快得多。如果树这种数据结构作为索引，那我们每查找一次数据就需要从磁盘中**读取一个节点，也就是我们说的一个磁盘块**，但是平衡二叉树可是**每个节点只存储一个键值和数据的**
::: tip
 **那为什么不是B树而是B+树呢？**每一个索引在 InnoDB 里面对应一棵 B+ 树。
::: 
**B+树非叶子节点上是不存储数据的，仅存储键值**，**而B树节点中不仅存储键值，也会存储数据，会读取很多不必要的数据**。**innodb中页的默认大小是16KB，如果不存储数据，那么就会存储更多的键值**，相应的**树的阶数（节点的子节点树）就会更大，树就会更矮更胖**，如此一来我们查找数据进**行磁盘的IO次数有会再次减少**，数据查询的效率也会更快。

B+树的叶子节点有一条链相连，而B+树的叶子节点各自独立

B+树的叶节点由一条链相连

**由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键**

**B+树的叶节点由一条链相连**

### InnoDB 的索引模型
::: tip
1.在 InnoDB 中，每一张表其实就是多个 B+ 树，即`一个主键索引树`和`多个非主键索引树`。 

2.执行查询的效率，一般来说使用`主键索引 > 使用非主键索引` > 不使用索引，具体需要结合场景。

3.`如果不使用索引进行查询，则从主索引 B+ 树的叶子节点进行遍历`。
::: 
下面来看一个案例帮助我们理解主键索引和非主键索引

```sql
mysql> create table T(
  id int primary key, 
  k int not null, 
  name varchar(16),
index (k))engine=InnoDB;
```
![img](/mysql/base/dcda101051f28502bd5c4402b292e38d.png)
::: tip
 主键索引的叶子存该行的数据，二级索引(非主键索引)的叶子节点存的就是`主键的值`,不是索引

 因为要根据这个值进行回表，再在主键索引里面`直接从叶子节点里面拿到值`，不需要进行一次IO去磁盘找。

 为啥存值不存引用（数据在磁盘的地址指针）？因为一旦发生`页分裂`或者`页合并`，就得去`维护`这个地址`指针`，更麻烦。
::: 
*再举个栗子*

- 如果语句是 `select * from T where ID=500`，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；
- 如果语句是 `select * from T where k=5`，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，`再到 ID 索引树搜索一次`。这个过程称为`回表`。
- 也就是说，基于非主键索引的查询需要`多扫描一棵索引树`。因此，我们在应用中应该`尽量使用主键查询`。

### 索引维护
::: tip
以上面这个图为栗子，如果我们插入值为700的R6很简单插入到R5后面，如果新插入的 ID 值为 400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。
::: 
#### 页分裂

*值得我们注意的是*
::: tip
 而更糟的情况是，如果 `R5 所在的数据页已经满了`，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为`页分裂`。在这种情况下，性能自然会受影响。
::: 
所以一般我们使用`主键自增`这种方法就可以`防止页分裂`.

在建表语句中一般是这么定义的： `NOT NULL PRIMARY KEY AUTO_INCREMENT`。

#### 页合并
::: tip
 当然有分裂就有合并。当`相邻`两个页由于删除了数据，`利用率很低之后，会将数据页做合并`。合并的过程，可以认为是分裂过程的逆过程。
::: 
我们可以使用`逻辑删除(状态位)`来`防止页合并`的产生.

#### 不用业务字段做主键

1. 业务字段不一定是递增的，有`可能`会造成主键索引的`页分裂`，导致性能不稳定。 
2. 二级索引存储的值是主键，如果使用业务字段占用`大小不好控制`，如果`业务字段过长可能会导致二级索引占用空间过大`，利用率不高。

#### 总结
::: tip
 显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。

 所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。
::: 

::: tip
提问：如果我们要重建索引，以下做法可取吗
::: 
```sql
##对于普通索引
alter table T drop index k;
alter table T add index(k);

##对于主键索引
alter table T drop primary key;
alter table T add primary key(id);
```

答：

重建索引 k 的做法是合理的，可以达到省空间的目的。但是，重建主键的过程不合理。

不论是删除主键还是创建主键，都会将整个表重建。所以连着执行这两个语句的话，第一个语句就白做了。这两个语句，你可以用这个语句代替

```sql
 alter table T engine=InnoDB
```

