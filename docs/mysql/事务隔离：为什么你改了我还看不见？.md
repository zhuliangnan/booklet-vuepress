## 事务隔离：为什么你改了我还看不见？
::: tip
 事务支持是在引擎层实现的
::: 
### 事物的特点

| 特性   | 作用                                                 | 备注                                                         |
| ------ | ---------------------------------------------------- | ------------------------------------------------------------ |
| 原子性 | 保证并发操作                                         | 比如多个用户并发转账                                         |
| 一致性 | 保证数据一致                                         | 转账前后两个账户的金额总和保持不变                           |
| 隔离性 | 保证并发事务独立执行，对数据库的影响和串行执行一致。 | 比如多个用户网一个账户转账，最后转账的结果也应该和他们按照先后次序转账的结果一样 |
| 持久性 | 保证数据存储，任何事务或者系统故障都不会导致数据丢失 | 转账结果可保存                                               |

### 隔离性与隔离级别

- **读未提交** ：读到其他事务未提交的数据的，即存在脏读问题
- **读已提交** ：就是事务要等另一个事物提交后才能读取数据 解决脏读，但是有可能A事务没有提交，B事务就已经更改了并且提交了。会导致  不可重复读(针对的是更新)---同一事务内，不同的时刻读到的同一批数据可能是不一样的
- **可重复读(Mysql默认)**：就是在开始读取数据（事物开启）时，不再允许修改操作。但是可能会有会有幻读(针对的是新增)--A在修改，B插入了一条数据，A修改完在读取发现多了一条，好像出现幻觉

- **串行化** ：将事务的执行变为顺序执行

配置的方式是，将启动参数 `transaction-isolation` 的值设置成 READ-COMMITTED。

你可以用 `show variables` 来查看当前的值。

```sql
mysql> show variables like 'transaction_isolation';

+-----------------------+----------------+

| Variable_name | Value |

+-----------------------+----------------+

| transaction_isolation | READ-COMMITTED |

+-----------------------+----------------+
```
下面结合案例分析结果

假设数据表 T 中只有一列，其中一行的值为 1，下面是按照时间顺序执行两个事务的行为

![img](/mysql/base/7dea45932a6b722eb069d2264d0066f8.png)

- 若隔离级别是“读未提交”， 则 V1 的值就是 2。这时候事务 B 虽然还没有提交，但是结果已经被 A 看到了。因此，V2、V3 也都是 2。
- 若隔离级别是“读提交”，则 V1 是 1，V2 的值是 2。事务 B 的更新在提交后才能被 A 看到。所以， V3 的值也是 2。
- 若隔离级别是“可重复读”，则 V1、V2 是 1，V3 是 2。之所以 V2 还是 1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。
- 若隔离级别是“串行化”，则在事务 B 执行“将 1 改成 2”的时候，会被锁住。直到事务 A 提交后，事务 B 才可以继续执行。所以从 A 的角度看， V1、V2 值是 1，V3 的值是 2。.
::: tip
 在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准

 `RC级别`下，MVCC视图会在`每一个语句前创建一个`，所以在RC级别下，`一个事务是可以看到另外一个事务已经提交的内容`，因为它在`每一次查询`之前`都会`重新`给予最新的数据创建一个新的MVCC视图`。

 `RR级别`下，MVCC视图实在`开始事务的时候就创建好了`，这个`视图会一直使用`，直到该事务结束。 这里要注意不同的隔离级别他们的一致性事务视图创建的时间点是不同的。 RU：没有视图的概念，直接返回最小行数据。 

RCRead Committed，读提交）：在每一行SQL语句执行的时候创建。 RR（Repeatable Read，可重复读）：在事务启动的时候创建。 Serial：通过锁来实现数据访问，没有视图的概念。
::: 

::: warning
 注意:

 在“`可重复读`”隔离级别下，这个视图是在`事务启动`时创建的，整个事务存在期间都用这个视图。

 在“`读提交`”隔离级别下，这个视图是在每个 `SQL 语句开始执行`的时候创建的。

 这里需要注意的是，“`读未提交`”隔离级别下`直接返回记录上的最新值`，`没有视图概念`；

 而“串行化”`隔离级别`下直接用`加锁`的方式来避免并行访问。
::: 

### 事务隔离的实现
::: warning
 在 MySQL 中，实际上除了`记录变更记录`，还会记录一条`变更相反`的`回滚操作记录`，前者记录在`redo log`，后者记录在`undo log`
::: 
假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。

![img](/mysql/base/d9c313809e5ac148fc39feff532f0fee.png)
::: tip
在T1时，开启事务A，读到1，对应read-view-A。 在T2时，事务a执行update，将1改成2； 

在T3时，开启事务B，读到2，对应read-view-B。 在T4时，事务b执行update，将2改成3； 

在T5时，事务c执行update，将3改成4； 在T6时，开启事务C，读到4，对应read-view-C。 

所以 假如在T7时，有事务d将4改成5，都不会影响read-view-A，read-view-B，read-view-C。

这3个读视图分别`将当前值做相应的回滚操作得到`。 主要体现‘`可重复读`’的基本原理
::: 
系统会判断，当没有事务再需要用到这些回滚日志时，`回滚日志会被删除`
::: tip
 当没有比回滚日志更早的读视图（读视图在事务开启时创建）的时候，这个数据`不会再有谁驱使它回滚`了，这个回滚日志也就失去了用武之地，可以`删除`了
::: 
所以请尽可能`不要使用长事务`， 长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。其次还会占用锁资源，也可能拖垮整个库。

长事务会带来哪些问题？

1. 占有锁资源，可能拖垮整个库 
2. 长事务可能导致暂时需要保存很多undo log(回滚日志)，会占用内存空间。

### 事务的启动方式

1. 显式启动事务语句， `begin 或 start transaction`。配套的提交语句是 `commit`，回滚语句是 `rollback`。
2. `set autocommit=0`，这个命令会将这个`线程的自动提交关掉`。意味着如果你只执行一个 select 语句，这个事务就启动了，而且并`不会自动提交`。这个事务持续存在直到你`主动执行` `commit 或 rollback 语句，或者断开连接`。
::: tip
 在没有显式开启事务(没begin 或 start transaction)的情况下，可认为每个sql的执行都算是一个事务，如果你不commit 那么它会一直存在从而变成长事务(就是说，你自己关闭了自动提交，然后一个select也会一直占用，从而变成长事务。
::: 
因此，建议总是使用 `set autocommit=1`, 通过显式语句的方式来启动事务。

### 事务查询

你可以在 information_schema 库的 innodb_trx 这个表中查询长事务，比如下面这个语句，用于查找持续时间超过 60s 的事务。

```sql
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60
```

