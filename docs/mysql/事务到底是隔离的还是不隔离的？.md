## 事务到底是隔离的还是不隔离的？
::: tip
 如果是`可重复读`隔离级别，事务 T 启动的时候会创建一个视图 `read-view`，之后事务 T 执行期间，即使有其他事务修改了数据，事务 T 看到的仍然跟在启动时看到的一样

 一个事务要`更新一行`，如果刚好有另外`一个事务拥有这一行的行锁`，会被锁住，进入等待状态。问题是，既然进入了等待状态，那么等到这个事务自己获取到行锁要更新数据的时候，`它读到的值又是什么呢？`
::: 
在 MySQL 里，有两个“视图”的概念：

- 一个是 view。它是一个用查询语句定义的虚拟表

- 另一个是 InnoDB 在实现 MVCC 时用到的`一致性读视图`，即 consistent read view，用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现。

  一致性读`没有物理结构`，作用是事务执行期间`用来定义“我能看到什么数据”`。

### “快照”在 MVCC(一致性读) 里是怎么工作的？

InnoDB 里面`每个`事务有一个`唯一的事务 ID`，叫作 `transaction id`。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。
::: tip
 而`每行数据`也都是有多个版本的,`每次事务更新数据`的时候，都会生成一个`新的数据版本`，并且把 `transaction id` 赋值给这个数据版本的`事务 ID`，记为 `row trx_id`。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。

 也就是说，数据表中的`一行记`录，其实`可能有多个版本 (row)`，每个版本有自己的 row trx_id。
::: 
行状态变更图

![img](/mysql/base/68d08d277a6f7926a41cc5541d3dfced.png)

图代表一个行数据的四个版本,最新版本为V4,其中U1,U2,U3代表`undo log`回滚日志.而 V1、V2、V3 并不是物理上`真实存在`的，而是每次需要的时候根据当前版本和 undo log 计算出来的。比如，需要 V2 的时候，就是通过 V4 依次执行 U3、U2 算出来。
::: tip
 按照`可重复读`的定义，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。

 因此，一个事务只需要在启动的时候声明说:

 `“以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版本”`

 当然，如果“上一个版本”也不可见，那就得继续往前找。还有，如果是这个事务自己更新的数据，它自己还是要认的。

 `在实现上`， InnoDB `为每个事务构造了一个数组`，用来`保存这个事务启动瞬间`，当前正在“活跃”的所有事务 ID。“活跃”指的就是，`启动了但还没提交`。

 数组里面事务 `ID 的最小值`记为`低水位`，当前系统里面已经创建过的事务 `ID 的最大值加 1` 记为`高水位`。

 这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。

 这个视图数组把所有的 row trx_id 分成了几种不同的情况。
::: 
![img](/mysql/base/882114aaf55861832b4270d44507695e.png)



- 如果落在`绿色`部分，表示这个版本是`已提交的事务`或者是`当前事务自己生成`的，这个数据是可见的；
- 如果落在`红色`部分，表示这个版本是由`将来`启动的事务生成的，是肯定不可见的；
- 如果落在`黄色`部分，那就包括两种情况

​       a. 若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见；

​       b. 若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。
::: warning
 `黄色区间`是包含了`已经提交的事务`的，已经提交的事务的id可以比最低水位大，但小于最高水位(已经创建过的事务最大值+1)。比如，`黄色部分`有5，6，7，8，9这5个事务，9是当前事务，5，6，8是正在执行中的事务，7是已经提交的事务id。那么当前视图数组是[5 6 8 9]，最低水位是5，最高水位是10。事务7落在落在黄色区间，不在数组中，但已提交，所以也可见。
::: 
下面看一个案例

```sql
mysql> CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `k` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;
insert into t(id, k) values(1,1),(2,2);
```

事务ABC的执行过程

`begin/start transaction` 命令并不是一个事务的起点，在执行到它们之后的`第一个`操作 InnoDB 表的`语句`，事务`才真正启动`。如果你想要马上启动一个事务，可以使用 `start transaction with consistent snapshot` 这个命令。

![img](/mysql/base/823acf76e53c0bdba7beab45e72e90d6.png)

分析一下事务A的结果为什么是1

- 不妨假设事务 A 开始前，系统里面只有一个活跃事务 ID 是 99；
- 事务 A、B、C 的版本号分别是 100、101、102，且当前系统里只有这四个事务；
- 三个事务开始前，(1,1）这一行数据的 row trx_id 是 90。

这样，事务 A 的视图数组就是[99,100], 事务 B 的视图数组是[99,100,101], 事务 C 的视图数组是[99,100,101,102]。

画出跟事务 A 查询逻辑有关的操作

![img](/mysql/base/9416c310e406519b7460437cb0c5c149.png)
::: tip
 从图中可以看到，第一个有效更新是事务 C，把数据从 (1,1) 改成了 (1,2)。这时候，这个数据的最新版本的 row trx_id 是 102，而 90 这个版本已经成为了历史版本。

 第二个有效更新是事务 B，把数据从 (1,2) 改成了 (1,3)。这时候，这个数据的最新版本（即 row trx_id）是 101，而 102 又成为了历史版本。

 你可能注意到了，在事务 A 查询的时候，其实事务 B 还没有提交，但是它生成的 (1,3) 这个版本已经变成当前版本了。但这个版本对事务 A 必须是不可见的，否则就变成脏读了。

 好，现在事务 A 要来读数据了，它的视图数组是[99,100]。当然了，读数据都是从当前版本读起的。所以，事务 A 查询语句的读数据流程是这样的：
::: 
- 找到 (1,3) 的时候，判断出 row trx_id=101，比高水位大，处于红色区域，不可见；
- 接着，找到上一个历史版本，一看 row trx_id=102，比高水位大，处于红色区域，不可见；
- 再往前找，终于找到了（1,1)，它的 row trx_id=90，比低水位小，处于绿色区域，可见。

这样执行下来，虽然期间这一行数据被修改过，但是事务 A 不论在什么时候查询，看到这行数据的结果都是一致的，所以我们称之为一致性读。



总结:读的时候适用于以下规则

对于一个事务视图来说，`除了自己的更新总是可见以外`，有三种情况：

1. 版本未提交，不可见；
2. 版本已提交，但是是`在视图创建后`提交的，不可见；
3. 版本已提交，而且是在视图创建前提交的，可见。
::: warning
 (1,3) 还没提交，属于情况 1，不可见；(1,2) 虽然提交了，但是是在视图数组创建之后提交的，属于情况 2，不可见；(1,1) 是在视图数组创建之前提交的，可见。
::: 


### 更新逻辑

事务 B 的视图数组是先生成的，之后事务 C 才提交，不是应该看不见 (1,2) 吗，怎么能算出 (1,3) 来？

![img](/mysql/base/86ad7e8abe7bf16505b97718d8ac149f.png)
::: tip
 `更新数据`都是先`读后写的`，而这个读，只能读`当前的值`，称为“`当前读”（current read）`。

 简单来说就是`无论哪种隔离级别`的事务中，进行`update操作`都要在`此时此刻的最新值上`做修改
::: 
因此，在更新的时候，当前读拿到的数据是 (1,2)，更新后生成了新版本的数据 (1,3)，这个新版本的 `row trx_id `是`101`。
::: warning
 这里我们提到了一个概念，叫作`当前读`。其实，`除了 update 语句外`，`select 语句如果加锁，也是当前读`。
::: 
所以，如果把事务 A 的查询语句 select * from t where id=1 修改一下，加上 `lock in share mode` 或 `for update`，也都可以读到版本号是 101 的数据，返回的 k 的值是 `3`。下面这两个 select 语句，就是分别加了`读锁（S 锁，共享锁）`和`写锁（X 锁，排他锁）`。

```sql
mysql> select k from t where id=1 lock in share mode;
mysql> select k from t where id=1 for update;
```



假设事务 C 不是马上提交的，而是变成了下面的事务 C

![img](/mysql/base/cda2a0d7decb61e59dddc83ac51efb6e.png)

C事务没有马上提交,接着事务 B 的更新语句先发起了。前面说过了，虽然事务 C’还没提交，但是 (1,2) 这个版本也已经生成了，并且是当前的最新版本。那么，事务 B 的更新语句会怎么处理呢？

这时候，`“两阶段锁协议”`就要上场了。事务 C’没提交，也就是说 (1,2) 这个版本上的`写锁还没释放`。而事务 B 是`当前读`，必须要读最新版本，而且`必须加锁`，因此就被锁住了，必须等到事务 C’释放这个锁，才能继续它的当前读。

![img](/mysql/base/540967ea905e8b63630e496786d84c92.png)



### 事务的可重复读的能力是怎么实现的？
::: tip
 - 可重复读的`核心`就是`一致性读`（consistent read）；
 - 而事务`更新`数据的时候，只能用`当前读`。
 - 如果当前的记录的`行锁`被其他事务`占用`的话，就需要进入`锁等待`。
::: 
而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：

- 在`可重复读隔离级别`下，只需要在事务开始的时候`创建一致性视图`，之后事务里的其他查询都`共用这个一致性视图`；
- 在`读提交隔离级别`下，每一个语句执行前都会`重新算出`一个新的`视图`。



最后:那么，我们再看一下，在`读提交隔离级别`下，事务 A 和事务 B 的查询语句查到的 k，分别应该是多少呢？

![img](/mysql/base/18fd5179b38c8c3804b313c3582cd1be.jpg)

这时，事务 A 的查询语句的视图数组是在`执行这个语句的时候创建`的，时序上 (1,2)、(1,3) 的生成时间都在创建这个视图数组的时刻之前。但是，在这个时刻：

(1,3) 还没提交，属于情况 1，不可见；

(1,2) 提交了，属于情况 3，可见。

所以A是2



那么再来分析一下B:

B也是在set k=k+1才创建视图,此时事务C已经执行并提交对于B可见,同时B的更新对自身可见,所以B=3

