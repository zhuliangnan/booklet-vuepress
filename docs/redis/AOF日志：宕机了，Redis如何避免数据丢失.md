## AOF日志：宕机了，Redis如何避免数据丢失？
::: tip
 目前，Redis 的持久化主要有两大机制，即 AOF（Append Only File）日志和 RDB 快照
::: 
### AOF 日志是如何实现的？

![img](/redis/base/407f2686083afc37351cfd9107319a1f.jpg)

`提问`：AOF 为什么要先执行命令再记日志呢？

传统数据库的日志，例如 redo log（重做日志），记录的是修改后的数据，而 AOF 里记录的是 Redis 收到的`每一条命令`，这些命令是以文本形式保存的。

但是，`为了避免额外的检查开销`，Redis 在向 AOF 里面记录日志的时候，并不会先去对这些命令进行`语法检查`。所以，如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就可能会出错。而写后日志这种方式，就是先让系统执行命令，只有命令能执行成功，才会被记录到日志中，否则，系统就会直接向客户端报错。所以，Redis 使用写后日志这一方式的一大好处是，可以`避免出现记录错误命令的情况`。



`思考`：AOF 有两个潜在的风险。

首先，如果刚执行完一个命令，还没有来得及记日志就宕机了，那么这个命令和相应的数据就有丢失的风险。

其次，AOF 虽然避免了对当前命令的阻塞，但可能会给下一个操作带来阻塞风险。这是因为，AOF 日志也是在`主线程中执行的`，如果在把日志文件写入磁盘时，`磁盘写压力大`，就会导致`写盘很慢`，进而`导致后续的操作也无法执行了`。

`解决`：三种写回策略

### 三种写回策略

其实，对于这个问题，AOF 机制给我们提供了三个选择，也就是 AOF 配置项 `appendfsync` 的三个可选值。

- `Always`，`同步写回`：每个写命令执行完，`立马同步地将日志写回磁盘`；--不可避免地会影响主线程性能；
- `Everysec`，`每秒写回`：每个写命令执行完，`只是先把日志写到 AOF 文件的内存缓冲区`，每`隔一秒`把缓冲区中的内容写入磁盘；--但是如果发生宕机，`上一秒内未落盘的命令操作仍然会丢失` 折中方案
- `No`，操作系统控制的写回：每个写命令执行完，`只是先把日志写到 AOF 文件的内存缓冲区`，由`操作系统决定`何时将缓冲区内容写回磁盘。--只要 AOF 记录没有写回磁盘，一旦宕机对应的数据就丢失了；



### AOF日志文件太大了怎么办？

**AOF日志文件过大的问题:**

1.操作系统对文件大小有限制，超过则无法继续写入;

2.文件太大，`写入的效率`也会变`低`；

3.文件太大，`恢复数据`也很`耗时`

`解决`：AOF 重写机制

### AOF 重写机制

AOF重写机制指的是，对过大的AOF文件进行重写，以此来压缩AOF文件的大小。 具体的实现是：检查当前键值数据库中的键值对，记录`键值对的最终状态`，从而实现对 某个键值对 重复操作后产生的多条操作记录`压缩成一条`的效果。进而实现`压缩AOF文件的大小`。

同时重写过程是由fork子进程 -- `bgrewriteaof` 来完成的，这也是为了`避免阻塞主线程`

AOF重写，一个拷贝 `bgrewriteaof`,两处日志是指重写的时候新的命令会在`老的AOF`和`新的AOF日志`中都写入