## 底层数据结构：Redis快在哪里，又有哪些慢操作？

> 这里先做个概述：
>
> redis表现快的原因： 1、在内存中进行操作 2、高效的数据结构
>
> redis表现慢的原因： 1、哈希表的冲突问题和 rehash 可能带来的操作阻塞。
>
> 它接收到一个键值对操作后，能以微秒级别的速度找到数据，并快速完成操作。

### 键和值用什么结构组织？

为了实现从键到值的快速访问，Redis 使用了一个`哈希表(全局哈希表)`来保存所有键值对。

一个哈希表，其实就是一个数组，数组每个元素称为一个`哈希桶 entry`, entry 中存储的是 key 和 value 的`指针`，如果出现哈希冲突通过`拉链法`解决，也就是 entry 中多一个 next 指针，指向下一个在此位置的 entry .

哈希表的最大好处很明显，就是让我们可以用 O(1) 的时间复杂度来快速查找到键值对——我们只需要计算键的哈希值，就可以知道它所对应的哈希桶位置，然后就可以访问相应的 entry 元素

![img](/redis/base/1cc8eaed5d1ca4e3cdbaa5a3d48dfb5f.jpg)



### 为什么哈希表操作变慢了？

> `哈希表的冲突问题`和`rehash可能带来的操作阻塞`。
>
> `解决`：Redis 解决哈希冲突问题的方式，就是`链式哈希`。链式哈希也很容易理解，就是指同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接。

![img](/redis/base/8ac4cc6cf94968a502161f85d072e428.jpg)



> `链式哈希带来的问题`：这里依然存在一个问题，哈希冲突链上的元素只能通过指针逐一查找再操作。如果哈希表里写入的数据越来越多，哈希冲突可能也会越来越多，这就会导致某些哈希冲突链过长，进而导致这个链上的元素查找耗时长，效率降低。对于追求“快”的 Redis 来说，这是不太能接受的。
>
> `解决`：Redis 会对哈希表做 `rehash操作`。rehash 也就是增加现有的哈希桶数量，让逐渐增多的 entry 元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突。
>
> 其实这里和java中hashMap非常类似，都存在hash冲突，只不过redis为了提高性能，会将所有数据重hash一遍，hashMap 为了提高效率会将链表转换成红黑树。

#### rehash怎么做？存在的问题？渐进式rehash

> 其实，为了使 rehash 操作更高效，Redis 默认使用了两个全局哈希表：`哈希表1` 和`哈希表2`。
>
> 一开始，当你刚插入数据时，默认使用哈希表1，此时的哈希表2 并没有被分配空间。随着数据逐步增多，Redis 开始执行 rehash，这个过程分为三步：

1. 给哈希表2 分配更大的空间，例如是当前哈希表1 大小的两倍；

2. 把哈希表1 中的数据重新映射并拷贝到哈希表2 中；

3. 释放哈希表1 的空间。

> `rehash带来的问题`：但是第二步涉及大量的数据拷贝，如果一次性把哈希表 1 中的数据都迁移完，会造成 Redis 线程阻塞，无法服务其他请求。此时，Redis 就无法快速访问数据了。
>
> `解决`: 为了避免这个问题，Redis 采用了`渐进式rehash`。

简单来说就是在第二步拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；

等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries

`场景驱动`：假设访问一个key1，哈希后落到哈希桶1，然后遍历链表 在获取对key1对的value1后，会将哈希桶1中的所有键值对copy迁移到全局哈希表2，同理，假设key2哈希后落到哈希桶2上，在返回查到的value2后，会将哈希桶2上的键值对都迁移到全局哈希表2上。

> 渐进式rehash过程

1. 为ht[1]分配空间

2. 索引计数器rehashidx置零

3. 一次rehash之后，ht[0]上键值对放到ht[1],rehashidx加一

4. 全部rehash之后，rehashidx属性设置为-1

`提问`：后续对位置1数据的请求（查，改）是在表2还是表1？以及新的数据进来是存储在表2还是表1？

在rehash期间，字典的删除、查找、修改等在两个哈希表上进行。现在ht[0]里面找，找不到再去ht[1]找。新增则直接在ht[1]增加。

`思考`：String 类型来说，找到哈希桶就能直接增删改查了，所以，哈希表的 O(1) 操作复杂度也就是它的复杂度了。

### 键值对中值的数据类型 

1. String 2. List 3. Hash 4. Set 5. Sorted Set 6. Bitmap 7. GeoHash 8. HyperLogLog 9. Streams

除了String外，我们把List，Hash，Set，Sorted Set都属于集合类型 

### 键值对中值的数据类型的底层数据结构 

- 简单动态字符串 O(1) 
- 双向链表 O(n) 
- 压缩列表 O(n) 
- 哈希表 O(1) 
- 跳表 O(logN) 
- 整数数组 O(n) 

String:通过全局hash表查到值就能直接操作 集合类型：有两种底层实现结构，`哈希表`和`跳表`实现“`快`”，`整数数组`和`压缩链表``节省内存空间`。

![img](/redis/base/8219f7yy651e566d47cc9f661b399f01.jpg)



#### 压缩列表，跳表的特点

1. 压缩列表类似于一个数组，不同的是:压缩列表在表头有三个字段`zlbytes`,`zltail`和`zllen`分别表示`长度`，`列表尾的偏移量`和`列表中的entry的个数`，压缩列表尾部还有一个`zlend`，表示列表结束
   所以压缩列表定位第一个和最后一个是O(1),但其他就是O(n)，但是压缩链表存在的意义在于：`空间的紧凑节省空间`

![img](/redis/base/9587e483f6ea82f560ff10484aaca4a0.jpg)

1. 跳表：是在链表的基础上增加了多级索引，通过索引的几次跳转，实现数据快速定位

   ![img](/redis/base/1eca7135d38de2yy16681c2bbc4f3fb4.jpg)

提问：整数数组和压缩列表在查找时间复杂度方面并没有很大的优势，那为什么 Redis 还会把它们作为底层数据结构呢？

1、内存利用率，数组和压缩列表都是非常紧凑的数据结构，它比链表占用的内存要更少

2、数组对CPU高速缓存支持更友好，所以Redis在设计时，集合数据元素较少情况下，默认采用内存紧凑排列的方式存储，同时利用CPU高速缓存不会降低访问速度。当数据元素超过设定阈值后，避免查询时间复杂度太高，转为哈希和跳表数据结构存储，保证查询效率。



#### 不同操作的复杂度

- 单元素操作是基础；
- 范围操作非常耗时；
- 统计操作通常高效；
- 例外情况只有几个。



> 第一，单元素操作，是指每一种集合类型对单个数据实现的增删改查操作

例如，Hash 类型的 `HGET`、`HSET` 和 `HDEL`，Set 类型的 `SADD`、`SREM`、`SRANDMEMBER` 等。

这些操作的复杂度由集合采用的数据结构决定，例如，HGET、HSET 和 HDEL 是对哈希表做操作，所以它们的复杂度都是 O(1)；

Set 类型用哈希表作为底层数据结构时，它的 SADD、SREM、SRANDMEMBER 复杂度也是 O(1)。

这里，有个地方你需要`注意一下`，`集合类型支持同时对多个元素进行增删改查`，例如 Hash 类型的 `HMGET` 和 `HMSET`，Set 类型的 `SADD` 也支持同时增加多个元素。

此时，`这些操作的复杂度`，就是由`单个元素操作复杂度`和`元素个数`决定的。`例如，HMSET 增加 M 个元素时，复杂度就从 O(1) 变成 O(M) 了`。



> 第二，范围操作，是指集合类型中的遍历操作，可以返回集合中的所有数据

比如 Hash 类型的 `HGETALL` 和 Set 类型的 `SMEMBERS`，或者`返回一个范围内的部分数据`，比如 List 类型的 `LRANGE` 和 ZSet 类型的 `ZRANGE`。

这类操作的复杂度一般是 O(N)，比较耗时，我们应该`尽量避免`。

`不过`，Redis 从 2.8 版本开始提供了 SCAN 系列操作（包括 HSCAN，SSCAN 和 ZSCAN），这类操作实现了渐进式遍历，每次只返回有限数量的数据。这样一来，相比于 HGETALL、SMEMBERS 这类操作来说，就避免了一次性返回所有元素而导致的 Redis 阻塞



> 第三，统计操作，是指集合类型对集合中所有元素个数的记录

例如 LLEN 和 SCARD。这类操作复杂度只有 O(1)，这是因为当集合类型采用`压缩列表`、`双向链表`、`整数数组`这些数据结构时，这些结构中`专门记录了元素的个数统计`，`因此可以高效地完成相关操作`



> 第四，例外情况，是指某些数据结构的特殊记录

例如`压缩列表`和`双向链表`都会记录表头和表尾的偏移量。这样一来，对于 List 类型的 `LPOP`、`RPOP`、`LPUSH`、`RPUSH` 这四个操作来说，它们是在`列表的头尾增删元素`，这就可以通过`偏移量`直接定位，所以它们的复杂度也只有` O(1)`，可以实现快速操作。