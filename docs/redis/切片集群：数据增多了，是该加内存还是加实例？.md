## 切片集群：数据增多了，是该加内存还是加实例？

> 切片集群，也叫分片集群，就是指启动多个 Redis 实例组成一个集群，然后按照一定的规则，把收到的数据划分成多份，每一份用一个实例来保存

![img](/redis/base/793251ca784yyf6ac37fe46389094b26.jpg)

### 如何保存更多数据？

- `纵向扩展`：`升级`单个 Redis 实例的`资源配置`，包括增加内存容量、增加磁盘容量、使用更高配置的 CPU。就像下图中，原来的实例内存是 8GB，硬盘是 50GB，纵向扩展后，内存增加到 24GB，磁盘增加到 150GB。
- `横向扩展`：横向增加当前 Redis 实例的个数，就像下图中，原来使用 1 个 8GB 内存、50GB 磁盘的实例，现在使用三个相同配置的实例。

![img](/redis/base/7a512fec7eba789c6d098b834929701a.jpg)

在面向百万、千万级别的用户规模时，横向扩展的 Redis 切片集群会是一个非常好的选择。

`要想把切片集群用起来，我们就需要解决两大问题`：

1. 数据切片后，在多个实例之间如何分布？
2. 客户端怎么确定想要访问的数据在哪个实例上？



### 数据切片和实例的对应分布关系

#### 切片集群和 Redis Cluster 的联系与区别

> `Redis Cluster是切片集群的一种实现方案。`
>
> Redis Cluster：`实现切片集群`。 
>
> Redis Cluster方案采用`哈希槽（Hash Slot）`，处理`数据与实例`之间的`映射关系`；一个切片集群有`16384`个哈希槽，哈希槽`类似于数据分区`，每个键值对都会根据它的key被映射到一个哈希槽中。 映射步骤：根据key按照CRC16计算一个16bit值，再用16bit值对16384取模，每个模数代表一个相应编号的哈希槽

有5个哈希槽的Redis Cluster示意图

![img](/redis/base/7d070c8b19730b308bfaabbe82c2f1ab.jpg)

示意图中的切片集群一共有 3 个实例，同时假设有 5 个哈希槽，我们首先可以通过下面的命令手动分配哈希槽：

实例 1 保存哈希槽 0 和 1，实例 2 保存哈希槽 2 和 3，实例 3 保存哈希槽 4。

````css
redis-cli -h 172.16.19.3 –p 6379 cluster addslots 0,1
redis-cli -h 172.16.19.4 –p 6379 cluster addslots 2,3
redis-cli -h 172.16.19.5 –p 6379 cluster addslots 4
````

`注意：`在`手动分配哈希槽时`，需要把 16384 个槽都分配完，否则 Redis 集群无法正常工作。

### 客户端如何定位数据？

#### 哈希槽分布在哪个实例上?

> 在定位键值对数据时，它所处的哈希槽是可以通过计算得到的，这个计算可以在客户端发送请求时来执行。但是，要进一步定位到实例，`还需要知道哈希槽分布在哪个实例上`。

一般来说，`客户端和集群实例建立连接后`，实例就会把哈`希槽的分配信息发给客户端`。但是，在集群刚刚创建的时候，每个实例只知道自己被分配了哪些哈希槽，是不知道其他实例拥有的哈希槽信息的。

`那么，客户端为什么可以在访问任何一个实例时，都能获得所有的哈希槽信息呢？`

这是因为，Redis 实例会把自己的哈希槽信息`发给和它相连接的其它实例`，来完成哈希槽`分配信息的扩散`。当实例之间相互连接后，每个实例就有所有哈希槽的映射关系了。

#### 实例和哈希槽的对应关系发生变化怎么办

>但是，在集群中，实例和哈希槽的对应关系并不是一成不变的，最常见的变化有两个：
>
>- 在集群中，实例有`新增`或`删除`，Redis 需要`重新分配哈希槽`；
>- 为了`负载均衡`，Redis 需要把哈希槽在所有实例上重新分布一遍。

`Redis Cluster `方案提供了一种重定向机制,所谓的“`重定向`”，就是指，客户端给一个实例发送数据读写操作时，这个实例上并没有相应的数据，客户端要再给一个`新实例`发送操作命令。

`那客户端又是怎么知道重定向时的新实例的访问地址呢？`

当客户端把一个键值对的操作请求发给一个实例时，如果这个实例上并没有这个键值对映射的哈希槽，那么，这个实例就会给客户端返回下面的 `MOVED `命令响应结果，这个结果中就包含了新实例的访问地址。

````css
GET hello:key
(error) MOVED 13320 172.16.19.5:6379
````

`解释`：客户端请求的键值对所在的哈希槽 13320，实际是在 172.16.19.5 这个实例上。

通过返回的 MOVED 命令，就相当于把哈希槽所在的新实例的信息告诉给客户端了。这样一来，客户端就可以直接和 172.16.19.5 连接，并发送操作请求了。

![img](/redis/base/350abedefcdbc39d6a8a8f1874eb0809.jpg)

`注意`： 

客户端向实例 2 发送请求，但此时，Slot 2 中的数据只有一部分迁移到了实例 3，还有部分数据没有迁移。在这种迁移部分完成的情况下，客户端就会收到一条 ASK 报错信息

````css
GET hello:key
(error) ASK 13320 172.16.19.5:6379
````

`解释`：客户端请求的键值对所在的哈希槽 13320，在 172.16.19.5 这个实例3上，但是这个哈希槽正在迁移。

此时，客户端需要先给 172.16.19.5 这个实例3发送一个 `ASKING `命令。这个命令的意思是，让这个实例`允许执行客户端接下来发送的命令`。然后，客户端再向这个实例发送 GET 命令，以读取数据



在下图中，Slot 2 正在从实例 2 往实例 3 迁移，key1 和 key2 已经迁移过去，key3 和 key4 还在实例 2。

客户端向实例 2 请求 key2 后，就会收到实例 2 返回的 ASK 命令。ASK 命令表示两层含义：

第一，表明 Slot 数据还在迁移中；

第二，ASK 命令把客户端所请求数据的`最新实例地址`返回给客户端，此时，客户端需要给实例 3 发送` ASKING 命令，然后再发送操作命令`。

![img](/redis/base/e93ae7f4edf30724d58bf68yy714eeb0.jpg)



`注意`： 和 `MOVED` 命令不同，`ASK` 命令并`不会更新客户端缓存的哈希槽分配信息`。

所以，在上图中，如果客户端再次`请求 Slot 2` 中的数据，它`还是`会给`实例 2 发送请求`。这也就是说，ASK 命令的作用`只是让客户端能给新实例发送一次请求`，而`不像 MOVED` 命令那样，会`更改本地缓存`，让

后续所有命令`都发往新实例`。

### Redis Cluster为什么不采用把key直接映射到实例的方式，而采用哈希槽的方式?

1、整个集群存储`key的数量是无法预估`的，key的`数量非常多时，`直接记录每个key对应的实例映射关系，这个`映射表会非常庞大`，这个映射表无论是存储在服务端还是客户端都`占用了非常大的内存空间`。

2、Redis Cluster采用无中心化的模式（无proxy，客户端与服务端直连），客户端在某个节点访问一个key，如果这个key不在这个节点上，这个节点需要有纠正客户端路由到正确节点的能力（MOVED响应），这就

需要节点之间互相交换路由表，每个节点拥有整个集群完整的路由关系。`如果存储的都是key与实例的对应关系`，节点之间`交换信息也会变得非常庞大`，消耗过多的网络资源，而且就算交换完成，相当于每个节点都

需要额外存储其他节点的路由表，内存占用过大造成资源浪费。

3、当集群在扩容、缩容、数据均衡时，节点之间会发生`数据迁移`，迁移时需要`修改每个key的映射关系，维护成本高`。

4、而在中间增加一层哈希槽，可以把`数据和节点解耦`，`key通过Hash计算，只需要关心映射到了哪个哈希槽`，然后再通过`哈希槽和节点的映射表找到节点`，相当于消耗了很少的CPU资源，不但让数据分布更均匀，

还可以让这个映射表变得很小，利于客户端和服务端保存，节点之间交换信息时也变得轻量。