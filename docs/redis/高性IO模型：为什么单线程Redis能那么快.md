## 高性IO模型：为什么单线程Redis能那么快
::: tip
 我们通常说，Redis 是单线程，主要是指 Redis 的`网络IO `和`键值对读写`是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程。

 但 Redis 的其他功能，比如`持久化`、`异步删除`、`集群数据同步`等，其实是由`额外的线程执行`的。 
::: 


### Redis 为什么用单线程？

1. 频繁切换线程带来的额外开销
2. 线程同时访问共享资源的并发问题。为了避免这些问题，Redis 直接采用了单线程模式。

### 单线程的redis为什么这么快

1. 基于`内存`的数据结构。 
2. `高效的数据结构`。 例如哈希表和跳表。
3. `多路复用机制`。使其在网络 IO 操作中能并发处理大量的客户端请求，实现高吞吐率。

### 基于多路复用的高性能 I/O 模型
::: tip
 基于linux select/epoll ，内核可同时`监听`多个监听套接字和 多个已连接套接字 ，一旦内核监听到套接字上有数据返回，立刻交给redis线程处理数据

 为了在请求到达时能通知到 Redis 线程，select/epoll 提供了`基于事件的回调机制`，即针对不同事件的发生，调用相应的处理函数。

 简单来说 select 轮询遍历 文件对象的被监控的事件（accept, read, write）,一旦某个文件对象的监控事件被触发（读或者写或者请求就绪），满足条件，这个事件就会被放到事件队列进行处理，处理的过程就是调用对应的回调函数。
::: 
**基于多路复用的Redis高性能I/O模型**

![img](/redis/base/00ff790d4f6225aaeeebba34a71d8bea-16326217592192.jpg)

### 补充：Redis单线程处理IO请求性能瓶颈主要包括2个方面：

1、任意一个请求在server中一旦发生耗时，都会影响整个server的性能，也就是说后面的请求都要等前面这个耗时请求处理完成，自己才能被处理到。耗时的操作包括以下几种：

   a、操作bigkey：写入一个bigkey在分配内存时需要消耗更多的时间，同样，删除bigkey释放内存同样会产生耗时；

   b、使用复杂度过高的命令：例如SORT/SUNION/ZUNIONSTORE，或者O(N)命令，但是N很大，例如lrange key 0 -1一次查询全量数据；

   c、大量key集中过期：Redis的过期机制也是在主线程中执行的，大量key集中过期会导致处理一个请求时，耗时都在删除过期key，耗时变长；

   d、淘汰策略：淘汰策略也是在主线程执行的，当内存超过Redis内存上限后，每次写入都需要淘汰一些key，也会造成耗时变长；

   e、AOF刷盘开启always机制：每次写入都需要把这个操作刷到磁盘，写磁盘的速度远比写内存慢，会拖慢Redis的性能；

   f、主从全量同步生成RDB：虽然采用fork子进程生成数据快照，但fork这一瞬间也是会阻塞整个线程的，实例越大，阻塞时间越久；

2、并发量非常大时，单线程读写客户端IO数据存在性能瓶颈，虽然采用IO多路复用机制，但是读写客户端数据依旧是同步IO，只能单线程依次读取客户端的数据，无法利用到CPU多核。

针对问题1，一方面需要业务人员去规避，一方面Redis在4.0推出了lazy-free机制，把bigkey释放内存的耗时操作放在了异步线程中执行，降低对主线程的影响。

针对问题2，Redis在6.0推出了多线程，可以在高并发场景下利用CPU多核多线程读写客户端数据，进一步提升server性能，当然，只是针对客户端的读写是并行的，每个命令的真正操作依旧是单线程的。