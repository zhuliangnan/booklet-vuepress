(window.webpackJsonp=window.webpackJsonp||[]).push([[94],{551:function(t,s,a){"use strict";a.r(s);var v=a(7),_=Object(v.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"深入浅出索引一"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#深入浅出索引一"}},[t._v("#")]),t._v(" 深入浅出索引一")]),t._v(" "),a("h3",{attrs:{id:"索引的常见模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#索引的常见模型"}},[t._v("#")]),t._v(" 索引的常见模型")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("p",[t._v("三种常见、也比较简单的数据结构，它们分别是哈希表、有序数组和搜索树。")]),t._v(" "),a("p",[t._v("对于哈希表来说：")]),t._v(" "),a("p",[t._v("查找速度还可以，对于冲突我们还可以使用拉链法解决，但是涉及区间查找就真的gg了")]),t._v(" "),a("p",[t._v("所以哈希表这种结构适用于只有等值查询的场景")]),t._v(" "),a("p",[t._v("对于数组来说：")]),t._v(" "),a("p",[t._v("查找和区间查找是可以用二分法O(log(N))，仅仅看查询是最快的了")]),t._v(" "),a("p",[t._v("但是插入数据就gg了，需要移动了元素太多，内存消耗太大")])]),t._v(" "),a("h3",{attrs:{id:"数据库索引的原理-为什么要用-b-树-为什么不用二叉树"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据库索引的原理-为什么要用-b-树-为什么不用二叉树"}},[t._v("#")]),t._v(" 数据库索引的原理，为什么要用 B+树，为什么不用二叉树？")]),t._v(" "),a("p",[t._v("可以从几个维度去看这个问题，"),a("strong",[t._v("查询是否够快")]),t._v("，"),a("strong",[t._v("效率是否稳定")]),t._v("，"),a("strong",[t._v("存储数据多少")]),t._v("，**以及查找磁盘次数，**为什么不是二叉树，为什么不是平衡二叉树，为什么不是B树，而偏偏是B+树呢？")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("p",[a("strong",[t._v("为什么不是一般二叉树？")])])]),t._v(" "),a("p",[t._v("如果二叉树特殊化为一个"),a("code",[t._v("链表")]),t._v("，相当于"),a("code",[t._v("全表扫描")])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("p",[a("strong",[t._v("为什么不是平衡二叉树呢？")])])]),t._v(" "),a("p",[t._v("在内存比在磁盘的数据，查询效率快得多。如果树这种数据结构作为索引，那我们每查找一次数据就需要从磁盘中"),a("strong",[t._v("读取一个节点，也就是我们说的一个磁盘块")]),t._v("，但是平衡二叉树可是"),a("strong",[t._v("每个节点只存储一个键值和数据的")])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("p",[t._v("**那为什么不是B树而是B+树呢？**每一个索引在 InnoDB 里面对应一棵 B+ 树。")])]),t._v(" "),a("p",[a("strong",[t._v("B+树非叶子节点上是不存储数据的，仅存储键值")]),t._v("，"),a("strong",[t._v("而B树节点中不仅存储键值，也会存储数据，会读取很多不必要的数据")]),t._v("。"),a("strong",[t._v("innodb中页的默认大小是16KB，如果不存储数据，那么就会存储更多的键值")]),t._v("，相应的"),a("strong",[t._v("树的阶数（节点的子节点树）就会更大，树就会更矮更胖")]),t._v("，如此一来我们查找数据进"),a("strong",[t._v("行磁盘的IO次数有会再次减少")]),t._v("，数据查询的效率也会更快。")]),t._v(" "),a("p",[t._v("B+树的叶子节点有一条链相连，而B+树的叶子节点各自独立")]),t._v(" "),a("p",[t._v("B+树的叶节点由一条链相连")]),t._v(" "),a("p",[a("strong",[t._v("由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键")])]),t._v(" "),a("p",[a("strong",[t._v("B+树的叶节点由一条链相连")])]),t._v(" "),a("h3",{attrs:{id:"innodb-的索引模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#innodb-的索引模型"}},[t._v("#")]),t._v(" InnoDB 的索引模型")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("p",[t._v("1.在 InnoDB 中，每一张表其实就是多个 B+ 树，即"),a("code",[t._v("一个主键索引树")]),t._v("和"),a("code",[t._v("多个非主键索引树")]),t._v("。")]),t._v(" "),a("p",[t._v("2.执行查询的效率，一般来说使用"),a("code",[t._v("主键索引 > 使用非主键索引")]),t._v(" > 不使用索引，具体需要结合场景。")]),t._v(" "),a("p",[t._v("3."),a("code",[t._v("如果不使用索引进行查询，则从主索引 B+ 树的叶子节点进行遍历")]),t._v("。")])]),t._v(" "),a("p",[t._v("下面来看一个案例帮助我们理解主键索引和非主键索引")]),t._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[t._v("mysql"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("create")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("table")]),t._v(" T"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n  id "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("primary")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("key")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" \n  k "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("not")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" \n  name "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("varchar")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("16")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("index")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("k"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("engine")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("InnoDB")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[a("img",{attrs:{src:"/mysql/base/dcda101051f28502bd5c4402b292e38d.png",alt:"img"}})]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("p",[t._v("主键索引的叶子存该行的数据，二级索引(非主键索引)的叶子节点存的就是"),a("code",[t._v("主键的值")]),t._v(",不是索引")]),t._v(" "),a("p",[t._v("因为要根据这个值进行回表，再在主键索引里面"),a("code",[t._v("直接从叶子节点里面拿到值")]),t._v("，不需要进行一次IO去磁盘找。")]),t._v(" "),a("p",[t._v("为啥存值不存引用（数据在磁盘的地址指针）？因为一旦发生"),a("code",[t._v("页分裂")]),t._v("或者"),a("code",[t._v("页合并")]),t._v("，就得去"),a("code",[t._v("维护")]),t._v("这个地址"),a("code",[t._v("指针")]),t._v("，更麻烦。")])]),t._v(" "),a("p",[a("em",[t._v("再举个栗子")])]),t._v(" "),a("ul",[a("li",[t._v("如果语句是 "),a("code",[t._v("select * from T where ID=500")]),t._v("，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；")]),t._v(" "),a("li",[t._v("如果语句是 "),a("code",[t._v("select * from T where k=5")]),t._v("，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，"),a("code",[t._v("再到 ID 索引树搜索一次")]),t._v("。这个过程称为"),a("code",[t._v("回表")]),t._v("。")]),t._v(" "),a("li",[t._v("也就是说，基于非主键索引的查询需要"),a("code",[t._v("多扫描一棵索引树")]),t._v("。因此，我们在应用中应该"),a("code",[t._v("尽量使用主键查询")]),t._v("。")])]),t._v(" "),a("h3",{attrs:{id:"索引维护"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#索引维护"}},[t._v("#")]),t._v(" 索引维护")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("p",[t._v("以上面这个图为栗子，如果我们插入值为700的R6很简单插入到R5后面，如果新插入的 ID 值为 400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。")])]),t._v(" "),a("h4",{attrs:{id:"页分裂"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#页分裂"}},[t._v("#")]),t._v(" 页分裂")]),t._v(" "),a("p",[a("em",[t._v("值得我们注意的是")])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("p",[t._v("而更糟的情况是，如果 "),a("code",[t._v("R5 所在的数据页已经满了")]),t._v("，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为"),a("code",[t._v("页分裂")]),t._v("。在这种情况下，性能自然会受影响。")])]),t._v(" "),a("p",[t._v("所以一般我们使用"),a("code",[t._v("主键自增")]),t._v("这种方法就可以"),a("code",[t._v("防止页分裂")]),t._v(".")]),t._v(" "),a("p",[t._v("在建表语句中一般是这么定义的： "),a("code",[t._v("NOT NULL PRIMARY KEY AUTO_INCREMENT")]),t._v("。")]),t._v(" "),a("h4",{attrs:{id:"页合并"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#页合并"}},[t._v("#")]),t._v(" 页合并")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("p",[t._v("当然有分裂就有合并。当"),a("code",[t._v("相邻")]),t._v("两个页由于删除了数据，"),a("code",[t._v("利用率很低之后，会将数据页做合并")]),t._v("。合并的过程，可以认为是分裂过程的逆过程。")])]),t._v(" "),a("p",[t._v("我们可以使用"),a("code",[t._v("逻辑删除(状态位)")]),t._v("来"),a("code",[t._v("防止页合并")]),t._v("的产生.")]),t._v(" "),a("h4",{attrs:{id:"不用业务字段做主键"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#不用业务字段做主键"}},[t._v("#")]),t._v(" 不用业务字段做主键")]),t._v(" "),a("ol",[a("li",[t._v("业务字段不一定是递增的，有"),a("code",[t._v("可能")]),t._v("会造成主键索引的"),a("code",[t._v("页分裂")]),t._v("，导致性能不稳定。")]),t._v(" "),a("li",[t._v("二级索引存储的值是主键，如果使用业务字段占用"),a("code",[t._v("大小不好控制")]),t._v("，如果"),a("code",[t._v("业务字段过长可能会导致二级索引占用空间过大")]),t._v("，利用率不高。")])]),t._v(" "),a("h4",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("p",[t._v("显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。")]),t._v(" "),a("p",[t._v("所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。")])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("p",[t._v("提问：如果我们要重建索引，以下做法可取吗")])]),t._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##对于普通索引")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("alter")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("table")]),t._v(" T "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("drop")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("index")]),t._v(" k"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("alter")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("table")]),t._v(" T "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("add")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("index")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("k"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##对于主键索引")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("alter")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("table")]),t._v(" T "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("drop")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("primary")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("key")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("alter")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("table")]),t._v(" T "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("add")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("primary")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("key")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("答：")]),t._v(" "),a("p",[t._v("重建索引 k 的做法是合理的，可以达到省空间的目的。但是，重建主键的过程不合理。")]),t._v(" "),a("p",[t._v("不论是删除主键还是创建主键，都会将整个表重建。所以连着执行这两个语句的话，第一个语句就白做了。这两个语句，你可以用这个语句代替")]),t._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("alter")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("table")]),t._v(" T "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("engine")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("InnoDB")]),t._v("\n")])])])])}),[],!1,null,null,null);s.default=_.exports}}]);