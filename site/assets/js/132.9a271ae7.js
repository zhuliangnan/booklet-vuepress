(window.webpackJsonp=window.webpackJsonp||[]).push([[132],{499:function(e,s,v){"use strict";v.r(s);var _=v(7),t=Object(_.a)({},(function(){var e=this,s=e.$createElement,v=e._self._c||s;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h2",{attrs:{id:"高性io模型-为什么单线程redis能那么快"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#高性io模型-为什么单线程redis能那么快"}},[e._v("#")]),e._v(" 高性IO模型：为什么单线程Redis能那么快")]),e._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),v("p",[e._v("我们通常说，Redis 是单线程，主要是指 Redis 的"),v("code",[e._v("网络IO")]),e._v("和"),v("code",[e._v("键值对读写")]),e._v("是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程。")]),e._v(" "),v("p",[e._v("但 Redis 的其他功能，比如"),v("code",[e._v("持久化")]),e._v("、"),v("code",[e._v("异步删除")]),e._v("、"),v("code",[e._v("集群数据同步")]),e._v("等，其实是由"),v("code",[e._v("额外的线程执行")]),e._v("的。")])]),e._v(" "),v("h3",{attrs:{id:"redis-为什么用单线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redis-为什么用单线程"}},[e._v("#")]),e._v(" Redis 为什么用单线程？")]),e._v(" "),v("ol",[v("li",[e._v("频繁切换线程带来的额外开销")]),e._v(" "),v("li",[e._v("线程同时访问共享资源的并发问题。为了避免这些问题，Redis 直接采用了单线程模式。")])]),e._v(" "),v("h3",{attrs:{id:"单线程的redis为什么这么快"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#单线程的redis为什么这么快"}},[e._v("#")]),e._v(" 单线程的redis为什么这么快")]),e._v(" "),v("ol",[v("li",[e._v("基于"),v("code",[e._v("内存")]),e._v("的数据结构。")]),e._v(" "),v("li",[v("code",[e._v("高效的数据结构")]),e._v("。 例如哈希表和跳表。")]),e._v(" "),v("li",[v("code",[e._v("多路复用机制")]),e._v("。使其在网络 IO 操作中能并发处理大量的客户端请求，实现高吞吐率。")])]),e._v(" "),v("h3",{attrs:{id:"基于多路复用的高性能-i-o-模型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#基于多路复用的高性能-i-o-模型"}},[e._v("#")]),e._v(" 基于多路复用的高性能 I/O 模型")]),e._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),v("p",[e._v("基于linux select/epoll ，内核可同时"),v("code",[e._v("监听")]),e._v("多个监听套接字和 多个已连接套接字 ，一旦内核监听到套接字上有数据返回，立刻交给redis线程处理数据")]),e._v(" "),v("p",[e._v("为了在请求到达时能通知到 Redis 线程，select/epoll 提供了"),v("code",[e._v("基于事件的回调机制")]),e._v("，即针对不同事件的发生，调用相应的处理函数。")]),e._v(" "),v("p",[e._v("简单来说 select 轮询遍历 文件对象的被监控的事件（accept, read, write）,一旦某个文件对象的监控事件被触发（读或者写或者请求就绪），满足条件，这个事件就会被放到事件队列进行处理，处理的过程就是调用对应的回调函数。")])]),e._v(" "),v("p",[v("strong",[e._v("基于多路复用的Redis高性能I/O模型")])]),e._v(" "),v("p",[v("img",{attrs:{src:"/redis/base/00ff790d4f6225aaeeebba34a71d8bea-16326217592192.jpg",alt:"img"}})]),e._v(" "),v("h3",{attrs:{id:"补充-redis单线程处理io请求性能瓶颈主要包括2个方面"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#补充-redis单线程处理io请求性能瓶颈主要包括2个方面"}},[e._v("#")]),e._v(" 补充：Redis单线程处理IO请求性能瓶颈主要包括2个方面：")]),e._v(" "),v("p",[e._v("1、任意一个请求在server中一旦发生耗时，都会影响整个server的性能，也就是说后面的请求都要等前面这个耗时请求处理完成，自己才能被处理到。耗时的操作包括以下几种：")]),e._v(" "),v("p",[e._v("a、操作bigkey：写入一个bigkey在分配内存时需要消耗更多的时间，同样，删除bigkey释放内存同样会产生耗时；")]),e._v(" "),v("p",[e._v("b、使用复杂度过高的命令：例如SORT/SUNION/ZUNIONSTORE，或者O(N)命令，但是N很大，例如lrange key 0 -1一次查询全量数据；")]),e._v(" "),v("p",[e._v("c、大量key集中过期：Redis的过期机制也是在主线程中执行的，大量key集中过期会导致处理一个请求时，耗时都在删除过期key，耗时变长；")]),e._v(" "),v("p",[e._v("d、淘汰策略：淘汰策略也是在主线程执行的，当内存超过Redis内存上限后，每次写入都需要淘汰一些key，也会造成耗时变长；")]),e._v(" "),v("p",[e._v("e、AOF刷盘开启always机制：每次写入都需要把这个操作刷到磁盘，写磁盘的速度远比写内存慢，会拖慢Redis的性能；")]),e._v(" "),v("p",[e._v("f、主从全量同步生成RDB：虽然采用fork子进程生成数据快照，但fork这一瞬间也是会阻塞整个线程的，实例越大，阻塞时间越久；")]),e._v(" "),v("p",[e._v("2、并发量非常大时，单线程读写客户端IO数据存在性能瓶颈，虽然采用IO多路复用机制，但是读写客户端数据依旧是同步IO，只能单线程依次读取客户端的数据，无法利用到CPU多核。")]),e._v(" "),v("p",[e._v("针对问题1，一方面需要业务人员去规避，一方面Redis在4.0推出了lazy-free机制，把bigkey释放内存的耗时操作放在了异步线程中执行，降低对主线程的影响。")]),e._v(" "),v("p",[e._v("针对问题2，Redis在6.0推出了多线程，可以在高并发场景下利用CPU多核多线程读写客户端数据，进一步提升server性能，当然，只是针对客户端的读写是并行的，每个命令的真正操作依旧是单线程的。")])])}),[],!1,null,null,null);s.default=t.exports}}]);