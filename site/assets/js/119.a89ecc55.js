(window.webpackJsonp=window.webpackJsonp||[]).push([[119],{509:function(v,_,e){"use strict";e.r(_);var o=e(7),t=Object(o.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h2",{attrs:{id:"aof日志-宕机了-redis如何避免数据丢失"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#aof日志-宕机了-redis如何避免数据丢失"}},[v._v("#")]),v._v(" AOF日志：宕机了，Redis如何避免数据丢失？")]),v._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),e("p",[v._v("目前，Redis 的持久化主要有两大机制，即 AOF（Append Only File）日志和 RDB 快照")])]),v._v(" "),e("h3",{attrs:{id:"aof-日志是如何实现的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#aof-日志是如何实现的"}},[v._v("#")]),v._v(" AOF 日志是如何实现的？")]),v._v(" "),e("p",[e("img",{attrs:{src:"/redis/base/407f2686083afc37351cfd9107319a1f.jpg",alt:"img"}})]),v._v(" "),e("p",[e("code",[v._v("提问")]),v._v("：AOF 为什么要先执行命令再记日志呢？")]),v._v(" "),e("p",[v._v("传统数据库的日志，例如 redo log（重做日志），记录的是修改后的数据，而 AOF 里记录的是 Redis 收到的"),e("code",[v._v("每一条命令")]),v._v("，这些命令是以文本形式保存的。")]),v._v(" "),e("p",[v._v("但是，"),e("code",[v._v("为了避免额外的检查开销")]),v._v("，Redis 在向 AOF 里面记录日志的时候，并不会先去对这些命令进行"),e("code",[v._v("语法检查")]),v._v("。所以，如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就可能会出错。而写后日志这种方式，就是先让系统执行命令，只有命令能执行成功，才会被记录到日志中，否则，系统就会直接向客户端报错。所以，Redis 使用写后日志这一方式的一大好处是，可以"),e("code",[v._v("避免出现记录错误命令的情况")]),v._v("。")]),v._v(" "),e("p",[e("code",[v._v("思考")]),v._v("：AOF 有两个潜在的风险。")]),v._v(" "),e("p",[v._v("首先，如果刚执行完一个命令，还没有来得及记日志就宕机了，那么这个命令和相应的数据就有丢失的风险。")]),v._v(" "),e("p",[v._v("其次，AOF 虽然避免了对当前命令的阻塞，但可能会给下一个操作带来阻塞风险。这是因为，AOF 日志也是在"),e("code",[v._v("主线程中执行的")]),v._v("，如果在把日志文件写入磁盘时，"),e("code",[v._v("磁盘写压力大")]),v._v("，就会导致"),e("code",[v._v("写盘很慢")]),v._v("，进而"),e("code",[v._v("导致后续的操作也无法执行了")]),v._v("。")]),v._v(" "),e("p",[e("code",[v._v("解决")]),v._v("：三种写回策略")]),v._v(" "),e("h3",{attrs:{id:"三种写回策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三种写回策略"}},[v._v("#")]),v._v(" 三种写回策略")]),v._v(" "),e("p",[v._v("其实，对于这个问题，AOF 机制给我们提供了三个选择，也就是 AOF 配置项 "),e("code",[v._v("appendfsync")]),v._v(" 的三个可选值。")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("Always")]),v._v("，"),e("code",[v._v("同步写回")]),v._v("：每个写命令执行完，"),e("code",[v._v("立马同步地将日志写回磁盘")]),v._v("；--不可避免地会影响主线程性能；")]),v._v(" "),e("li",[e("code",[v._v("Everysec")]),v._v("，"),e("code",[v._v("每秒写回")]),v._v("：每个写命令执行完，"),e("code",[v._v("只是先把日志写到 AOF 文件的内存缓冲区")]),v._v("，每"),e("code",[v._v("隔一秒")]),v._v("把缓冲区中的内容写入磁盘；--但是如果发生宕机，"),e("code",[v._v("上一秒内未落盘的命令操作仍然会丢失")]),v._v(" 折中方案")]),v._v(" "),e("li",[e("code",[v._v("No")]),v._v("，操作系统控制的写回：每个写命令执行完，"),e("code",[v._v("只是先把日志写到 AOF 文件的内存缓冲区")]),v._v("，由"),e("code",[v._v("操作系统决定")]),v._v("何时将缓冲区内容写回磁盘。--只要 AOF 记录没有写回磁盘，一旦宕机对应的数据就丢失了；")])]),v._v(" "),e("h3",{attrs:{id:"aof日志文件太大了怎么办"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#aof日志文件太大了怎么办"}},[v._v("#")]),v._v(" AOF日志文件太大了怎么办？")]),v._v(" "),e("p",[e("strong",[v._v("AOF日志文件过大的问题:")])]),v._v(" "),e("p",[v._v("1.操作系统对文件大小有限制，超过则无法继续写入;")]),v._v(" "),e("p",[v._v("2.文件太大，"),e("code",[v._v("写入的效率")]),v._v("也会变"),e("code",[v._v("低")]),v._v("；")]),v._v(" "),e("p",[v._v("3.文件太大，"),e("code",[v._v("恢复数据")]),v._v("也很"),e("code",[v._v("耗时")])]),v._v(" "),e("p",[e("code",[v._v("解决")]),v._v("：AOF 重写机制")]),v._v(" "),e("h3",{attrs:{id:"aof-重写机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#aof-重写机制"}},[v._v("#")]),v._v(" AOF 重写机制")]),v._v(" "),e("p",[v._v("AOF重写机制指的是，对过大的AOF文件进行重写，以此来压缩AOF文件的大小。 具体的实现是：检查当前键值数据库中的键值对，记录"),e("code",[v._v("键值对的最终状态")]),v._v("，从而实现对 某个键值对 重复操作后产生的多条操作记录"),e("code",[v._v("压缩成一条")]),v._v("的效果。进而实现"),e("code",[v._v("压缩AOF文件的大小")]),v._v("。")]),v._v(" "),e("p",[v._v("同时重写过程是由fork子进程 -- "),e("code",[v._v("bgrewriteaof")]),v._v(" 来完成的，这也是为了"),e("code",[v._v("避免阻塞主线程")])]),v._v(" "),e("p",[v._v("AOF重写，一个拷贝 "),e("code",[v._v("bgrewriteaof")]),v._v(",两处日志是指重写的时候新的命令会在"),e("code",[v._v("老的AOF")]),v._v("和"),e("code",[v._v("新的AOF日志")]),v._v("中都写入")])])}),[],!1,null,null,null);_.default=t.exports}}]);