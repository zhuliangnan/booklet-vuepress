(window.webpackJsonp=window.webpackJsonp||[]).push([[127],{501:function(_,v,t){"use strict";t.r(v);var s=t(7),e=Object(s.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h2",{attrs:{id:"哨兵机制-主库挂了-如何不间断服务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#哨兵机制-主库挂了-如何不间断服务"}},[_._v("#")]),_._v(" 哨兵机制：主库挂了，如何不间断服务")]),_._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[_._v("TIP")]),_._v(" "),t("p",[_._v("哨兵机制的主要职责:")]),_._v(" "),t("p",[_._v("1、"),t("code",[_._v("监控")]),_._v("：通过PING来监控主从")]),_._v(" "),t("p",[_._v("2、"),t("code",[_._v("选主")]),_._v("：主库挂了，从从库中按一定的机制选择一个新主库")]),_._v(" "),t("p",[_._v("3、"),t("code",[_._v("通知")]),_._v("：通知其他从库和客户端新的主库信息")])]),_._v(" "),t("h3",{attrs:{id:"哨兵机制的基本流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#哨兵机制的基本流程"}},[_._v("#")]),_._v(" 哨兵机制的基本流程")]),_._v(" "),t("p",[t("img",{attrs:{src:"/redis/base/efcfa517d0f09d057be7da32a84cf2a1.jpg",alt:"img"}})]),_._v(" "),t("h3",{attrs:{id:"哨兵如何判断下线-主观下线和客观下线"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#哨兵如何判断下线-主观下线和客观下线"}},[_._v("#")]),_._v(" 哨兵如何判断下线?(主观下线和客观下线)")]),_._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[_._v("TIP")]),_._v(" "),t("p",[t("code",[_._v("主观下线")])]),_._v(" "),t("p",[t("code",[_._v("哨兵进程")]),_._v("会使用 "),t("code",[_._v("PING 命令")]),_._v("检测它自己和主、从库的网络连接情况，用来判断实例的状态。如果哨兵发现主库或从库对 PING 命令的响应超时了，那么，哨兵就会先把它标记为“主观下线”。")]),_._v(" "),t("p",[_._v("如果"),t("code",[_._v("检测的是从库")]),_._v("，那么，哨兵简单地把它标记为“"),t("code",[_._v("主观下线")]),_._v("”就行了，因为从库的下线影响一般不太大，集群的对外服务不会间断。")]),_._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[_._v("TIP")]),_._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[_._v("TIP")]),_._v(" "),t("p",[t("code",[_._v("客观下线")])]),_._v(" "),t("p",[_._v("但是，如果检测的是主库，"),t("code",[_._v("可能误判")]),_._v("，一般会发生在"),t("code",[_._v("集群网络压力较大")]),_._v("、"),t("code",[_._v("网络拥塞")]),_._v("，或者是"),t("code",[_._v("主库本身压力较大")]),_._v("的情况下")]),_._v(" "),t("p",[_._v("它通常会采用"),t("code",[_._v("多实例组成的集群模式")]),_._v("进行部署，这也被称为"),t("code",[_._v("哨兵集群")]),_._v("。"),t("code",[_._v("引入多个哨兵实例一起来判断")]),_._v("，就可以避免单个哨兵因为自身网络状况不好，而误判主库下线的情况。同时，多个哨兵的网络同时不稳定的概率较小，由它们一起做决策，误判率也能降低。")]),_._v(" "),t("p",[_._v("客观下线”的标准就是，当有 N 个哨兵实例时，最好要有"),t("code",[_._v("N/2 + 1")]),_._v(" 个实例判断主库为“主观下线”，"),t("code",[_._v("才能最终判定主库为“客观下线")]),_._v("”。")])])])]),_._v(" "),t("p",[_._v("客观下线判断示意图")]),_._v(" "),t("p",[t("img",{attrs:{src:"/redis/base/1945703abf16ee14e2f7559873e4e60d-16328109273262.jpg",alt:"img"}})]),_._v(" "),t("h3",{attrs:{id:"哨兵如何选定新主库-筛选-打分"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#哨兵如何选定新主库-筛选-打分"}},[_._v("#")]),_._v(" 哨兵如何选定新主库？（筛选-打分）")]),_._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[_._v("TIP")]),_._v(" "),t("p",[_._v("A.筛选过程：")]),_._v(" "),t("p",[_._v("​     1、从库是否在线")]),_._v(" "),t("p",[_._v("​     2、网络连接状态 -- 你使用配置项 "),t("code",[_._v("down-after-milliseconds * 10")]),_._v("。其中，"),t("code",[_._v("down-after-milliseconds")]),_._v(" 是我们认定"),t("code",[_._v("主从库断连的最大连接超时时间")]),_._v("。如果在 "),t("code",[_._v("down-after-milliseconds")]),_._v(" 毫秒 内，主从节点都没有通过网络联系上，我们就可以认为主从节点断连了,如果发生断连的次数超过了 "),t("code",[_._v("10")]),_._v(" 次，就说明这个从库的网络状况不好，"),t("code",[_._v("不适合作为新主库")]),_._v("。")]),_._v(" "),t("p",[_._v("B、三轮打分过程。")]),_._v(" "),t("p",[t("code",[_._v("只要在某一轮中，有从库得分最高，那么它就是主库了")]),_._v("，选主过程到此结束。如果没有出现得分最高的从库，那么就继续进行下一轮。")])]),_._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[_._v("TIP")]),_._v(" "),t("p",[t("code",[_._v("第一轮：优先级最高的从库得分高(优先级)。")])])]),_._v(" "),t("p",[_._v("用户可以通过 "),t("code",[_._v("slave-priority")]),_._v(" 配置项，给不同的从库设置不同优先级。")]),_._v(" "),t("p",[_._v("比如，你有两个从库，它们的内存大小不一样，你可以手动给内存大的实例设置一个高优先级。在选主时，哨兵会给优先级高的从库打高分，如果有一个从库优先级最高，那么它就是新主库了。如果从库的优先级都一样，那么哨兵开始第二轮打分。")]),_._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[_._v("TIP")]),_._v(" "),t("p",[t("code",[_._v("第二轮：和旧主库同步程度最接近的从库得分高(复制进度)。")])])]),_._v(" "),t("p",[t("code",[_._v("repl_backlog_buffer")]),_._v("这个缓冲区重，它的 "),t("code",[_._v("slave_repl_offset")]),_._v(" 需要最接近 "),t("code",[_._v("master_repl_offset")]),_._v("。")]),_._v(" "),t("p",[_._v("如果在所有从库中，有从库的 slave_repl_offset 最接近 master_repl_offset，那么它的得分就最高，可以作为新主库。")]),_._v(" "),t("p",[_._v("就像下图所示，旧主库的 master_repl_offset 是 1000，从库 1、2 和 3 的 slave_repl_offset 分别是 950、990 和 900，那么，从库 2 就应该被选为新主库。")]),_._v(" "),t("p",[t("img",{attrs:{src:"/redis/base/626yy88853a2d15b5196b922367140df.jpg",alt:"img"}})]),_._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[_._v("TIP")]),_._v(" "),t("p",[t("code",[_._v("第三轮：ID 号小的从库得分高(ID号)。")])])]),_._v(" "),t("p",[_._v("每个实例都会有一个 ID，这个 ID 就类似于这里的从库的编号。")]),_._v(" "),t("p",[_._v("目前，Redis 在选主库时，有一个默认的规定：在优先级和复制进度都相同的情况下，"),t("code",[_._v("ID 号最小的从库得分最高，会被选为新主库")]),_._v("。")]),_._v(" "),t("h3",{attrs:{id:"提问-哨兵在操作主从切换的过程中-客户端能否正常地进行请求操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#提问-哨兵在操作主从切换的过程中-客户端能否正常地进行请求操作"}},[_._v("#")]),_._v(" 提问：哨兵在操作主从切换的过程中，客户端能否正常地进行请求操作？")]),_._v(" "),t("p",[_._v("如果客户端使用了"),t("code",[_._v("读写分离")]),_._v("，那么"),t("code",[_._v("读请求可以在从库上正常执行")]),_._v("，不会受到影响。但是"),t("code",[_._v("由于此时主库已经挂了")]),_._v("，而且哨兵还没有选出新的主库，所以在这期间写"),t("code",[_._v("请求会失败")])]),_._v(" "),t("p",[_._v("失败持续的时间 = 哨兵切换主从的时间 + 客户端感知到新主库 的时间。")]),_._v(" "),t("p",[t("code",[_._v("如果不想让业务感知到异常")]),_._v("，客户端只能把"),t("code",[_._v("写失败的请求先缓存起来或写入消息队列中间件中")]),_._v("，等哨兵切换完主从后，再把这些写请求发给新的主库，但这种场景"),t("code",[_._v("只适合")]),_._v("对"),t("code",[_._v("写入请求返回值不敏感")]),_._v("的业务，而且还需要业务层做适配，"),t("code",[_._v("另外主从切换时间过长，也会导致客户端或消息队列中间件缓存写请求过多，切换完成之后重放这些请求的时间变长")]),_._v("。")])])}),[],!1,null,null,null);v.default=e.exports}}]);