(window.webpackJsonp=window.webpackJsonp||[]).push([[130],{474:function(v,_,e){"use strict";e.r(_);var s=e(7),t=Object(s.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h2",{attrs:{id:"底层数据结构-redis快在哪里-又有哪些慢操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#底层数据结构-redis快在哪里-又有哪些慢操作"}},[v._v("#")]),v._v(" 底层数据结构：Redis快在哪里，又有哪些慢操作？")]),v._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),e("p",[v._v("这里先做个概述：")]),v._v(" "),e("p",[v._v("redis表现快的原因： 1、在内存中进行操作 2、高效的数据结构")]),v._v(" "),e("p",[v._v("redis表现慢的原因： 1、哈希表的冲突问题和 rehash 可能带来的操作阻塞。")]),v._v(" "),e("p",[v._v("它接收到一个键值对操作后，能以微秒级别的速度找到数据，并快速完成操作。")])]),v._v(" "),e("h3",{attrs:{id:"键和值用什么结构组织"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#键和值用什么结构组织"}},[v._v("#")]),v._v(" 键和值用什么结构组织？")]),v._v(" "),e("p",[v._v("为了实现从键到值的快速访问，Redis 使用了一个"),e("code",[v._v("哈希表(全局哈希表)")]),v._v("来保存所有键值对。")]),v._v(" "),e("p",[v._v("一个哈希表，其实就是一个数组，数组每个元素称为一个"),e("code",[v._v("哈希桶 entry")]),v._v(", entry 中存储的是 key 和 value 的"),e("code",[v._v("指针")]),v._v("，如果出现哈希冲突通过"),e("code",[v._v("拉链法")]),v._v("解决，也就是 entry 中多一个 next 指针，指向下一个在此位置的 entry .")]),v._v(" "),e("p",[v._v("哈希表的最大好处很明显，就是让我们可以用 O(1) 的时间复杂度来快速查找到键值对——我们只需要计算键的哈希值，就可以知道它所对应的哈希桶位置，然后就可以访问相应的 entry 元素")]),v._v(" "),e("p",[e("img",{attrs:{src:"/redis/base/1cc8eaed5d1ca4e3cdbaa5a3d48dfb5f.jpg",alt:"img"}})]),v._v(" "),e("h3",{attrs:{id:"为什么哈希表操作变慢了"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么哈希表操作变慢了"}},[v._v("#")]),v._v(" 为什么哈希表操作变慢了？")]),v._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),e("p",[e("code",[v._v("哈希表的冲突问题")]),v._v("和"),e("code",[v._v("rehash可能带来的操作阻塞")]),v._v("。")]),v._v(" "),e("p",[e("code",[v._v("解决")]),v._v("：Redis 解决哈希冲突问题的方式，就是"),e("code",[v._v("链式哈希")]),v._v("。链式哈希也很容易理解，就是指同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接。")])]),v._v(" "),e("p",[e("img",{attrs:{src:"/redis/base/8ac4cc6cf94968a502161f85d072e428.jpg",alt:"img"}})]),v._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),e("p",[e("code",[v._v("链式哈希带来的问题")]),v._v("：这里依然存在一个问题，哈希冲突链上的元素只能通过指针逐一查找再操作。如果哈希表里写入的数据越来越多，哈希冲突可能也会越来越多，这就会导致某些哈希冲突链过长，进而导致这个链上的元素查找耗时长，效率降低。对于追求“快”的 Redis 来说，这是不太能接受的。")]),v._v(" "),e("p",[e("code",[v._v("解决")]),v._v("：Redis 会对哈希表做 "),e("code",[v._v("rehash操作")]),v._v("。rehash 也就是增加现有的哈希桶数量，让逐渐增多的 entry 元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突。")]),v._v(" "),e("p",[v._v("其实这里和java中hashMap非常类似，都存在hash冲突，只不过redis为了提高性能，会将所有数据重hash一遍，hashMap 为了提高效率会将链表转换成红黑树。")])]),v._v(" "),e("h4",{attrs:{id:"rehash怎么做-存在的问题-渐进式rehash"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rehash怎么做-存在的问题-渐进式rehash"}},[v._v("#")]),v._v(" rehash怎么做？存在的问题？渐进式rehash")]),v._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),e("p",[v._v("其实，为了使 rehash 操作更高效，Redis 默认使用了两个全局哈希表："),e("code",[v._v("哈希表1")]),v._v(" 和"),e("code",[v._v("哈希表2")]),v._v("。")]),v._v(" "),e("p",[v._v("一开始，当你刚插入数据时，默认使用哈希表1，此时的哈希表2 并没有被分配空间。随着数据逐步增多，Redis 开始执行 rehash，这个过程分为三步：")])]),v._v(" "),e("ol",[e("li",[e("p",[v._v("给哈希表2 分配更大的空间，例如是当前哈希表1 大小的两倍；")])]),v._v(" "),e("li",[e("p",[v._v("把哈希表1 中的数据重新映射并拷贝到哈希表2 中；")])]),v._v(" "),e("li",[e("p",[v._v("释放哈希表1 的空间。")])])]),v._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),e("p",[e("code",[v._v("rehash带来的问题")]),v._v("：但是第二步涉及大量的数据拷贝，如果一次性把哈希表 1 中的数据都迁移完，会造成 Redis 线程阻塞，无法服务其他请求。此时，Redis 就无法快速访问数据了。")]),v._v(" "),e("p",[e("code",[v._v("解决")]),v._v(": 为了避免这个问题，Redis 采用了"),e("code",[v._v("渐进式rehash")]),v._v("。")])]),v._v(" "),e("p",[v._v("简单来说就是在第二步拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；")]),v._v(" "),e("p",[v._v("等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries")]),v._v(" "),e("p",[e("code",[v._v("场景驱动")]),v._v("：假设访问一个key1，哈希后落到哈希桶1，然后遍历链表 在获取对key1对的value1后，会将哈希桶1中的所有键值对copy迁移到全局哈希表2，同理，假设key2哈希后落到哈希桶2上，在返回查到的value2后，会将哈希桶2上的键值对都迁移到全局哈希表2上。")]),v._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),e("p",[v._v("渐进式rehash过程")])]),v._v(" "),e("ol",[e("li",[e("p",[v._v("为ht[1]分配空间")])]),v._v(" "),e("li",[e("p",[v._v("索引计数器rehashidx置零")])]),v._v(" "),e("li",[e("p",[v._v("一次rehash之后，ht[0]上键值对放到ht[1],rehashidx加一")])]),v._v(" "),e("li",[e("p",[v._v("全部rehash之后，rehashidx属性设置为-1")])])]),v._v(" "),e("p",[e("code",[v._v("提问")]),v._v("：后续对位置1数据的请求（查，改）是在表2还是表1？以及新的数据进来是存储在表2还是表1？")]),v._v(" "),e("p",[v._v("在rehash期间，字典的删除、查找、修改等在两个哈希表上进行。现在ht[0]里面找，找不到再去ht[1]找。新增则直接在ht[1]增加。")]),v._v(" "),e("p",[e("code",[v._v("思考")]),v._v("：String 类型来说，找到哈希桶就能直接增删改查了，所以，哈希表的 O(1) 操作复杂度也就是它的复杂度了。")]),v._v(" "),e("h3",{attrs:{id:"键值对中值的数据类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#键值对中值的数据类型"}},[v._v("#")]),v._v(" 键值对中值的数据类型")]),v._v(" "),e("ol",[e("li",[v._v("String 2. List 3. Hash 4. Set 5. Sorted Set 6. Bitmap 7. GeoHash 8. HyperLogLog 9. Streams")])]),v._v(" "),e("p",[v._v("除了String外，我们把List，Hash，Set，Sorted Set都属于集合类型")]),v._v(" "),e("h3",{attrs:{id:"键值对中值的数据类型的底层数据结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#键值对中值的数据类型的底层数据结构"}},[v._v("#")]),v._v(" 键值对中值的数据类型的底层数据结构")]),v._v(" "),e("ul",[e("li",[v._v("简单动态字符串 O(1)")]),v._v(" "),e("li",[v._v("双向链表 O(n)")]),v._v(" "),e("li",[v._v("压缩列表 O(n)")]),v._v(" "),e("li",[v._v("哈希表 O(1)")]),v._v(" "),e("li",[v._v("跳表 O(logN)")]),v._v(" "),e("li",[v._v("整数数组 O(n)")])]),v._v(" "),e("p",[v._v("String:通过全局hash表查到值就能直接操作 集合类型：有两种底层实现结构，"),e("code",[v._v("哈希表")]),v._v("和"),e("code",[v._v("跳表")]),v._v("实现“"),e("code",[v._v("快")]),v._v("”，"),e("code",[v._v("整数数组")]),v._v("和"),e("code",[v._v("压缩链表``节省内存空间")]),v._v("。")]),v._v(" "),e("p",[e("img",{attrs:{src:"/redis/base/8219f7yy651e566d47cc9f661b399f01.jpg",alt:"img"}})]),v._v(" "),e("h4",{attrs:{id:"压缩列表-跳表的特点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#压缩列表-跳表的特点"}},[v._v("#")]),v._v(" 压缩列表，跳表的特点")]),v._v(" "),e("ol",[e("li",[v._v("压缩列表类似于一个数组，不同的是:压缩列表在表头有三个字段"),e("code",[v._v("zlbytes")]),v._v(","),e("code",[v._v("zltail")]),v._v("和"),e("code",[v._v("zllen")]),v._v("分别表示"),e("code",[v._v("长度")]),v._v("，"),e("code",[v._v("列表尾的偏移量")]),v._v("和"),e("code",[v._v("列表中的entry的个数")]),v._v("，压缩列表尾部还有一个"),e("code",[v._v("zlend")]),v._v("，表示列表结束\n所以压缩列表定位第一个和最后一个是O(1),但其他就是O(n)，但是压缩链表存在的意义在于："),e("code",[v._v("空间的紧凑节省空间")])])]),v._v(" "),e("p",[e("img",{attrs:{src:"/redis/base/9587e483f6ea82f560ff10484aaca4a0.jpg",alt:"img"}})]),v._v(" "),e("ol",[e("li",[e("p",[v._v("跳表：是在链表的基础上增加了多级索引，通过索引的几次跳转，实现数据快速定位")]),v._v(" "),e("p",[e("img",{attrs:{src:"/redis/base/1eca7135d38de2yy16681c2bbc4f3fb4.jpg",alt:"img"}})])])]),v._v(" "),e("p",[v._v("提问：整数数组和压缩列表在查找时间复杂度方面并没有很大的优势，那为什么 Redis 还会把它们作为底层数据结构呢？")]),v._v(" "),e("p",[v._v("1、内存利用率，数组和压缩列表都是非常紧凑的数据结构，它比链表占用的内存要更少")]),v._v(" "),e("p",[v._v("2、数组对CPU高速缓存支持更友好，所以Redis在设计时，集合数据元素较少情况下，默认采用内存紧凑排列的方式存储，同时利用CPU高速缓存不会降低访问速度。当数据元素超过设定阈值后，避免查询时间复杂度太高，转为哈希和跳表数据结构存储，保证查询效率。")]),v._v(" "),e("h4",{attrs:{id:"不同操作的复杂度"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#不同操作的复杂度"}},[v._v("#")]),v._v(" 不同操作的复杂度")]),v._v(" "),e("ul",[e("li",[v._v("单元素操作是基础；")]),v._v(" "),e("li",[v._v("范围操作非常耗时；")]),v._v(" "),e("li",[v._v("统计操作通常高效；")]),v._v(" "),e("li",[v._v("例外情况只有几个。")])]),v._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),e("p",[v._v("第一，单元素操作，是指每一种集合类型对单个数据实现的增删改查操作")])]),v._v(" "),e("p",[v._v("例如，Hash 类型的 "),e("code",[v._v("HGET")]),v._v("、"),e("code",[v._v("HSET")]),v._v(" 和 "),e("code",[v._v("HDEL")]),v._v("，Set 类型的 "),e("code",[v._v("SADD")]),v._v("、"),e("code",[v._v("SREM")]),v._v("、"),e("code",[v._v("SRANDMEMBER")]),v._v(" 等。")]),v._v(" "),e("p",[v._v("这些操作的复杂度由集合采用的数据结构决定，例如，HGET、HSET 和 HDEL 是对哈希表做操作，所以它们的复杂度都是 O(1)；")]),v._v(" "),e("p",[v._v("Set 类型用哈希表作为底层数据结构时，它的 SADD、SREM、SRANDMEMBER 复杂度也是 O(1)。")]),v._v(" "),e("p",[v._v("这里，有个地方你需要"),e("code",[v._v("注意一下")]),v._v("，"),e("code",[v._v("集合类型支持同时对多个元素进行增删改查")]),v._v("，例如 Hash 类型的 "),e("code",[v._v("HMGET")]),v._v(" 和 "),e("code",[v._v("HMSET")]),v._v("，Set 类型的 "),e("code",[v._v("SADD")]),v._v(" 也支持同时增加多个元素。")]),v._v(" "),e("p",[v._v("此时，"),e("code",[v._v("这些操作的复杂度")]),v._v("，就是由"),e("code",[v._v("单个元素操作复杂度")]),v._v("和"),e("code",[v._v("元素个数")]),v._v("决定的。"),e("code",[v._v("例如，HMSET 增加 M 个元素时，复杂度就从 O(1) 变成 O(M) 了")]),v._v("。")]),v._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),e("p",[v._v("第二，范围操作，是指集合类型中的遍历操作，可以返回集合中的所有数据")])]),v._v(" "),e("p",[v._v("比如 Hash 类型的 "),e("code",[v._v("HGETALL")]),v._v(" 和 Set 类型的 "),e("code",[v._v("SMEMBERS")]),v._v("，或者"),e("code",[v._v("返回一个范围内的部分数据")]),v._v("，比如 List 类型的 "),e("code",[v._v("LRANGE")]),v._v(" 和 ZSet 类型的 "),e("code",[v._v("ZRANGE")]),v._v("。")]),v._v(" "),e("p",[v._v("这类操作的复杂度一般是 O(N)，比较耗时，我们应该"),e("code",[v._v("尽量避免")]),v._v("。")]),v._v(" "),e("p",[e("code",[v._v("不过")]),v._v("，Redis 从 2.8 版本开始提供了 SCAN 系列操作（包括 HSCAN，SSCAN 和 ZSCAN），这类操作实现了渐进式遍历，每次只返回有限数量的数据。这样一来，相比于 HGETALL、SMEMBERS 这类操作来说，就避免了一次性返回所有元素而导致的 Redis 阻塞")]),v._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),e("p",[v._v("第三，统计操作，是指集合类型对集合中所有元素个数的记录")])]),v._v(" "),e("p",[v._v("例如 LLEN 和 SCARD。这类操作复杂度只有 O(1)，这是因为当集合类型采用"),e("code",[v._v("压缩列表")]),v._v("、"),e("code",[v._v("双向链表")]),v._v("、"),e("code",[v._v("整数数组")]),v._v("这些数据结构时，这些结构中"),e("code",[v._v("专门记录了元素的个数统计")]),v._v("，"),e("code",[v._v("因此可以高效地完成相关操作")])]),v._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),e("p",[v._v("第四，例外情况，是指某些数据结构的特殊记录")])]),v._v(" "),e("p",[v._v("例如"),e("code",[v._v("压缩列表")]),v._v("和"),e("code",[v._v("双向链表")]),v._v("都会记录表头和表尾的偏移量。这样一来，对于 List 类型的 "),e("code",[v._v("LPOP")]),v._v("、"),e("code",[v._v("RPOP")]),v._v("、"),e("code",[v._v("LPUSH")]),v._v("、"),e("code",[v._v("RPUSH")]),v._v(" 这四个操作来说，它们是在"),e("code",[v._v("列表的头尾增删元素")]),v._v("，这就可以通过"),e("code",[v._v("偏移量")]),v._v("直接定位，所以它们的复杂度也只有"),e("code",[v._v("O(1)")]),v._v("，可以实现快速操作。")])])}),[],!1,null,null,null);_.default=t.exports}}]);