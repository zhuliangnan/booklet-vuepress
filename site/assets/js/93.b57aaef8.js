(window.webpackJsonp=window.webpackJsonp||[]).push([[93],{557:function(v,_,o){"use strict";o.r(_);var s=o(7),t=Object(s.a)({},(function(){var v=this,_=v.$createElement,o=v._self._c||_;return o("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[o("h2",{attrs:{id:"日志系统-一条sql更新语句是如何执行的"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#日志系统-一条sql更新语句是如何执行的"}},[v._v("#")]),v._v(" 日志系统：一条SQL更新语句是如何执行的？")]),v._v(" "),o("div",{staticClass:"custom-block tip"},[o("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),o("p",[v._v("一条Sql更新是如何执行的呢，查询语句的那一套流程，更新语句也是同样会走一遍。")])]),v._v(" "),o("div",{staticClass:"language-sql extra-class"},[o("pre",{pre:!0,attrs:{class:"language-sql"}},[o("code",[v._v("mysql"),o("span",{pre:!0,attrs:{class:"token operator"}},[v._v(">")]),v._v(" "),o("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("update")]),v._v(" T "),o("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("set")]),v._v(" c"),o("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v("c"),o("span",{pre:!0,attrs:{class:"token operator"}},[v._v("+")]),o("span",{pre:!0,attrs:{class:"token number"}},[v._v("1")]),v._v(" "),o("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("where")]),v._v(" ID"),o("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),o("span",{pre:!0,attrs:{class:"token number"}},[v._v("2")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n")])])]),o("div",{staticClass:"custom-block tip"},[o("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),o("p",[v._v("你执行语句前要先连接数据库，这是"),o("code",[v._v("连接器")]),v._v("的工作。")]),v._v(" "),o("p",[v._v("前面我们说过，在一个表上有更新的时候，跟这个表有关的"),o("code",[v._v("查询缓存会失效")]),v._v("，所以这条语句就会把表上所有"),o("code",[v._v("缓存结果")]),v._v("都清空。这也就是我们一般不建议使用查询缓存的原因。")]),v._v(" "),o("p",[v._v("接下来，"),o("code",[v._v("分析器")]),v._v("会通过"),o("code",[v._v("词法和语法解析")]),v._v("知道这是一条更新语句。")]),v._v(" "),o("p",[o("code",[v._v("优化器")]),v._v("决定要使用 ID 这个索引。然后，执行器负责具体"),o("code",[v._v("执行")]),v._v("，找到这一行，"),o("code",[v._v("然后更新")]),v._v("。")])]),v._v(" "),o("p",[v._v("与查询流程不一样的是，更新流程还涉及两个重要的日志模块，"),o("code",[v._v("redo log（重做日志")]),v._v("）和 "),o("code",[v._v("binlog（归档日志）")])]),v._v(" "),o("p",[v._v("binlog是默认关闭的，打开才会有binlog")]),v._v(" "),o("h3",{attrs:{id:"重要的日志模块-redo-log"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#重要的日志模块-redo-log"}},[v._v("#")]),v._v(" 重要的日志模块：redo log")]),v._v(" "),o("div",{staticClass:"custom-block tip"},[o("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),o("p",[v._v("具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 "),o("code",[v._v("redo log")]),v._v(" 里面，"),o("code",[v._v("并更新内存")]),v._v("，这个时候"),o("code",[v._v("更新就算完成")]),v._v("了。")]),v._v(" "),o("p",[v._v("同时，"),o("code",[v._v("InnoDB 引擎")]),v._v("会在"),o("code",[v._v("适当")]),v._v("的时候，将这个操作记录"),o("code",[v._v("更新到磁盘")]),v._v("里面，而这个更新往往是在"),o("code",[v._v("系统比较空闲")]),v._v("的时候做.")]),v._v(" "),o("p",[o("code",[v._v("redo log")]),v._v(" 是循环写的，"),o("code",[v._v("空间固定会用完，满了就先写到磁盘")])])]),v._v(" "),o("div",{staticClass:"custom-block tip"},[o("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),o("p",[v._v("比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么这块总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。")])]),v._v(" "),o("p",[o("img",{attrs:{src:"/mysql/base/16a7950217b3f0f4ed02db5db59562a7.png",alt:"img"}})]),v._v(" "),o("div",{staticClass:"custom-block tip"},[o("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),o("p",[o("code",[v._v("write pos")]),v._v(" 是当前记录的位置，"),o("code",[v._v("check point")]),v._v("记录的是上次刷盘的位置，如果write pos "),o("code",[v._v("快要追上")]),v._v(" check point ，代表内存快"),o("code",[v._v("写满")]),v._v("了，脏页很多，需要强制刷盘")])]),v._v(" "),o("p",[v._v("有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 "),o("code",[v._v("crash-safe")]),v._v("。")]),v._v(" "),o("p",[v._v("好比数据库"),o("code",[v._v("重启")]),v._v("了，内存中的"),o("code",[v._v("数据页没有同步到磁盘")]),v._v("中，可以通过redo log日志恢复")]),v._v(" "),o("h3",{attrs:{id:"重要的日志模块-binlog"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#重要的日志模块-binlog"}},[v._v("#")]),v._v(" 重要的日志模块：binlog")]),v._v(" "),o("div",{staticClass:"custom-block tip"},[o("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),o("p",[v._v("为什么会有两份日志？")]),v._v(" "),o("p",[v._v("因为最开始 MySQL 里并没有 "),o("code",[v._v("InnoDB")]),v._v(" 引擎。")]),v._v(" "),o("p",[v._v("MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 "),o("code",[v._v("crash-safe")]),v._v(" 的能力，"),o("code",[v._v("binlog")]),v._v(" 日志只能用于"),o("code",[v._v("归档")]),v._v("。")]),v._v(" "),o("p",[v._v("而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统——也就是 "),o("code",[v._v("redo log")]),v._v(" 来实现 crash-safe 能力。")])]),v._v(" "),o("ul",[o("li",[o("p",[o("code",[v._v("redo log 是 InnoDB 引擎特有的")]),v._v("；binlog 是 MySQL 的 "),o("code",[v._v("Server 层")]),v._v("实现的，所有引擎都可以使用。")])]),v._v(" "),o("li",[o("p",[v._v("redo log 是"),o("code",[v._v("物理日志")]),v._v("，记录的是“在"),o("code",[v._v("某个数据页上做了什么修改")]),v._v("”；"),o("code",[v._v("binlog")]),v._v(" 是"),o("code",[v._v("逻辑日志")]),v._v("，记录的是这个"),o("code",[v._v("语句的原始逻辑")]),v._v("，比如“给 ID=2 这一行的 c 字段加 1 ”。")])]),v._v(" "),o("li",[o("p",[o("code",[v._v("redo log 是循环写的")]),v._v("，空间固定会用完；"),o("code",[v._v("binlog")]),v._v(" 是可以"),o("code",[v._v("追加写入的")]),v._v("。“追加写”是指 "),o("code",[v._v("binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志")]),v._v("。")]),v._v(" "),o("p",[v._v("下面我们来看一下下面这个语句的执行过程")])])]),v._v(" "),o("div",{staticClass:"language-sql extra-class"},[o("pre",{pre:!0,attrs:{class:"language-sql"}},[o("code",[v._v("mysql"),o("span",{pre:!0,attrs:{class:"token operator"}},[v._v(">")]),v._v(" "),o("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("update")]),v._v(" T "),o("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("set")]),v._v(" c"),o("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v("c"),o("span",{pre:!0,attrs:{class:"token operator"}},[v._v("+")]),o("span",{pre:!0,attrs:{class:"token number"}},[v._v("1")]),v._v(" "),o("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("where")]),v._v(" ID"),o("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),o("span",{pre:!0,attrs:{class:"token number"}},[v._v("2")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n")])])]),o("ol",[o("li",[v._v("执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。")]),v._v(" "),o("li",[v._v("执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口"),o("code",[v._v("写入")]),v._v("这行新数据。")]),v._v(" "),o("li",[v._v("引擎将这行新数据"),o("code",[v._v("更新到内存")]),v._v("中，同时将这个更新操作记录到"),o("code",[v._v("redo log")]),v._v(" 里面，此时 redo log 处于 "),o("code",[v._v("prepare 状态")]),v._v("。然后"),o("code",[v._v("告知执行器执行完成了，随时可以提交事务")]),v._v("。")]),v._v(" "),o("li",[o("code",[v._v("执行器生成这个操作的 binlog")]),v._v("，并把 binlog "),o("code",[v._v("写入磁盘")]),v._v("。执行器调用引擎的提交事务接口，引擎把刚刚写入的 "),o("code",[v._v("redo log 改成提交（commit）状态，更新完成")]),v._v("。")])]),v._v(" "),o("div",{staticClass:"custom-block tip"},[o("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),o("p",[v._v("简单的说--对数据操作的行为（加减），由「执行器」完成；对数据读取行为，由「引擎」完成。")])]),v._v(" "),o("p",[v._v("图中浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。")]),v._v(" "),o("p",[o("img",{attrs:{src:"/mysql/base/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png",alt:"img"}})]),v._v(" "),o("div",{staticClass:"custom-block tip"},[o("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),o("p",[v._v('最后三步看上去有点“绕”，将 redo log 的写入拆成了两个步骤：prepare 和 commit，这就是"'),o("code",[v._v("两阶段提交")]),v._v('"。')])]),v._v(" "),o("h3",{attrs:{id:"两阶段提交"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#两阶段提交"}},[v._v("#")]),v._v(" 两阶段提交")]),v._v(" "),o("div",{staticClass:"custom-block tip"},[o("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),o("p",[v._v("为什么必须有“"),o("code",[v._v("两阶段提交")]),v._v("”呢？这是为了让两份日志之间的逻辑一致。要说明这个问题")]),v._v(" "),o("p",[v._v("我们得从一个问题说起："),o("code",[v._v("怎样让数据库恢复到半个月内任意一秒的状态？")])])]),v._v(" "),o("p",[v._v("当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做：")]),v._v(" "),o("ol",[o("li",[v._v("首先，找到最近的一次"),o("code",[v._v("全量备份(整库备份)")]),v._v("，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到"),o("code",[v._v("临时库")]),v._v("；")]),v._v(" "),o("li",[v._v("然后，从备份的时间点开始，将备份的 "),o("code",[v._v("binlog 依次取出来，重放到中午误删表之前的那个时刻")]),v._v(";")])]),v._v(" "),o("p",[v._v("由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完 redo log 再写 binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。")]),v._v(" "),o("h4",{attrs:{id:"先写-redo-log-后写-binlog"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#先写-redo-log-后写-binlog"}},[v._v("#")]),v._v(" 先写 redo log 后写 binlog")]),v._v(" "),o("div",{staticClass:"custom-block tip"},[o("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),o("p",[v._v("先写 redo log 后写 binlog。")]),v._v(" "),o("p",[v._v("假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，"),o("code",[v._v("系统即使崩溃，仍然能够把数据恢复回来")]),v._v("，所以恢复后这一行 c 的值是 1。但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。然后你会发现，"),o("code",[v._v("如果需要用这个 binlog 来恢复临时库的话")]),v._v("，由于这个语句的 "),o("code",[v._v("binlog 丢失")]),v._v("，这个临时库就会"),o("code",[v._v("少了这一次更新")]),v._v("，恢复出来的这一行 c 的值就是 0，"),o("code",[v._v("与原库的值不同")]),v._v("。")])]),v._v(" "),o("h4",{attrs:{id:"先写-binlog-后写-redo-log"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#先写-binlog-后写-redo-log"}},[v._v("#")]),v._v(" 先写 binlog 后写 redo log")]),v._v(" "),o("div",{staticClass:"custom-block tip"},[o("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),o("p",[v._v("先写 binlog 后写 redo log。")]),v._v(" "),o("p",[v._v("如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个"),o("code",[v._v("事务")]),v._v("无效，所以这一行 c 的值是 0。")]),v._v(" "),o("p",[v._v("但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。")]),v._v(" "),o("p",[v._v("所以，"),o("code",[v._v("在之后用 binlog 来恢复的时候就多了一个事务出来")]),v._v("，恢复出来的这一行 c 的值就是 1，与原库的值不同。")])]),v._v(" "),o("div",{staticClass:"custom-block tip"},[o("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),o("p",[v._v("总结：")]),v._v(" "),o("p",[v._v("本质上是因为 "),o("code",[v._v("redo log 负责事务")]),v._v("； "),o("code",[v._v("binlog负责归档恢复")]),v._v("； 各司其职，相互配合，才提供(保证)了现有功能的完整性；")])]),v._v(" "),o("p",[o("code",[v._v("nnodb_flush_log_at_trx_commit")]),v._v(" 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘，这样可以保证 MySQL 异常重启之后 数据不丢失。")]),v._v(" "),o("p",[o("code",[v._v("sync_binlog")]),v._v(" 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数也建议你设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。")])])}),[],!1,null,null,null);_.default=t.exports}}]);