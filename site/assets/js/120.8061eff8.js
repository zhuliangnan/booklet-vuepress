(window.webpackJsonp=window.webpackJsonp||[]).push([[120],{508:function(v,_,s){"use strict";s.r(_);var e=s(7),t=Object(e.a)({},(function(){var v=this,_=v.$createElement,s=v._self._c||_;return s("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[s("h2",{attrs:{id:"rdb内存快照-宕机后-redis如何快速恢复"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rdb内存快照-宕机后-redis如何快速恢复"}},[v._v("#")]),v._v(" RDB内存快照：宕机后，Redis如何快速恢复？")]),v._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),s("p",[v._v("实现类似照片记录效果的方式，就是把某一时刻的状态以文件的形式写到磁盘上，也就是快照。这样一来，即使宕机，快照文件也不会丢失，数据的可靠性也就得到了保证。这个快照文件就称为 RDB 文件，其中，RDB 就是 Redis DataBase 的缩写。")]),v._v(" "),s("p",[v._v("RDB文件是"),s("code",[v._v("二进制数据")])])]),v._v(" "),s("p",[v._v("我们还要考虑"),s("code",[v._v("两个关键问题")]),v._v("：")]),v._v(" "),s("p",[v._v("**对哪些数据做快照？**这关系到快照的执行效率问题；")]),v._v(" "),s("p",[v._v("**做快照时，数据还能被增删改吗？**这关系到 Redis 是否被阻塞，能否同时正常处理请求。")]),v._v(" "),s("p",[v._v("拿拍照片来举例子。我们在拍照时，通常要关注两个问题：如何取景？也就是说，我们打算把哪些人、哪些物拍到照片中；在按快门前，要记着提醒朋友不要乱动，否则拍出来的照片就模糊了")]),v._v(" "),s("h3",{attrs:{id:"给哪些内存数据做快照"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#给哪些内存数据做快照"}},[v._v("#")]),v._v(" 给哪些内存数据做快照？")]),v._v(" "),s("p",[v._v("Redis 的数据都在内存中，为了提供所有数据的可靠性保证，它执行的是"),s("code",[v._v("全量快照")]),v._v("，也就是说，把"),s("code",[v._v("内存中的所有数据")]),v._v("都记录到磁盘中。")]),v._v(" "),s("p",[v._v("Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave。")]),v._v(" "),s("p",[s("code",[v._v("save：")]),v._v("在主线程中执行，会"),s("code",[v._v("导致阻塞")]),v._v("；")]),v._v(" "),s("p",[s("code",[v._v("bgsave：")]),v._v("创建一个"),s("code",[v._v("子进程")]),v._v("，专门用于"),s("code",[v._v("写入 RDB 文件")]),v._v("，"),s("code",[v._v("避免")]),v._v("了主线程的"),s("code",[v._v("阻塞")]),v._v("，这也是 Redis RDB 文件生成的"),s("code",[v._v("默认配置")]),v._v("。")]),v._v(" "),s("h3",{attrs:{id:"快照时数据能修改吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#快照时数据能修改吗"}},[v._v("#")]),v._v(" 快照时数据能修改吗?")]),v._v(" "),s("p",[s("code",[v._v("举例：")]),v._v("假设有4GB数据要做快照，需要20s，在做快照的 20s 时间里，如果这 4GB 的数据都不能被修改，Redis 就不能处理对这些数据的写操作，那无疑就会给业务服务造成巨大的影响。")]),v._v(" "),s("p",[v._v("你可能会想到，可以用 bgsave 避免阻塞啊。")]),v._v(" "),s("p",[v._v("这里我就要说到一个常见的误区了，"),s("code",[v._v("避免阻塞和正常处理写操作并不是一回事")]),v._v("。此时，主线程的确"),s("code",[v._v("没有阻塞")]),v._v("，可以正常"),s("code",[v._v("接收请求")]),v._v("，但是，为了保证快照完整性，它"),s("code",[v._v("只能处理读操作")]),v._v("，因为不能修改正在执行快照的数据")]),v._v(" "),s("p",[v._v("允许修改")]),v._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),s("p",[v._v("为了快照而暂停写操作，肯定是不能接受的。所以这个时候，Redis 就会借助操作系统提供的"),s("code",[v._v("写时复制技术（Copy-On-Write, COW")]),v._v("），在执行快照的同时，"),s("code",[v._v("正常处理写操作")]),v._v("。")]),v._v(" "),s("p",[v._v("Redis会使用bgsave对当前内存中的所有数据做快照，这个操作是子进程在后台完成的，如果主线程需要修改数据，这块数据就会被复制一份，生成该"),s("code",[v._v("数据的副本")]),v._v("。然后，"),s("code",[v._v("主线程在这个数据副本上进行修改")]),v._v("。同时，bgsave 子进程可以继续把原来的数据写入 RDB 文件。")]),v._v(" "),s("p",[v._v("下为示意图")])]),v._v(" "),s("p",[s("img",{attrs:{src:"/redis/base/a2e5a3571e200cb771ed8a1cd14d5558.jpg",alt:"img"}})]),v._v(" "),s("h3",{attrs:{id:"可以每秒做一次快照吗-全量快照和增量快照"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#可以每秒做一次快照吗-全量快照和增量快照"}},[v._v("#")]),v._v(" 可以每秒做一次快照吗？（全量快照和增量快照）")]),v._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),s("p",[v._v("不可以的")]),v._v(" "),s("p",[s("code",[v._v("全量快照的问题")]),v._v("：虽然 bgsave 执行时不阻塞主线程，但是，如果频繁地执行"),s("code",[v._v("全量快照")]),v._v("，也会带来两方面的开销。")])]),v._v(" "),s("ol",[s("li",[v._v("快照时间过短会"),s("code",[v._v("加大磁盘写入压力")])]),v._v(" "),s("li",[v._v("频繁fork子进程 "),s("code",[v._v("fork过程会阻塞主线程")]),v._v("--虽然，子进程在创建后不会再阻塞主线程，但是，fork 这个创建过程本身会阻塞主线程")])]),v._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),s("p",[v._v("此时，我们可以做"),s("code",[v._v("增量快照")]),v._v("，所谓增量快照，就是指，做了一次全量快照后，后续的快照"),s("code",[v._v("只对修改的数据进行快照记录")]),v._v("，这样可以避免每次全量快照的开销。")]),v._v(" "),s("p",[v._v("但是，这么做的前提是，"),s("code",[v._v("我们需要记住哪些数据被修改了")]),v._v("这会带来额外的空间开销问题")]),v._v(" "),s("p",[v._v("如果我们对每一个键值对的修改，都做个记录，那么，如果有 1 万个被修改的键值对，我们就需要有 1 万条额外的记录。")]),v._v(" "),s("p",[v._v("而且，有的时候，键值对非常小，比如只有 32 字节，而记录它被修改的元数据信息，可能就需要 8 字节，这样的画，为了“记住”修改，引入的额外空间开销比较大。这对于内存资源宝贵的 Redis 来说，有些得不偿失")])]),v._v(" "),s("p",[v._v("增量快照示意图")]),v._v(" "),s("p",[s("img",{attrs:{src:"/redis/base/8a1d515269cd23595ee1813e8dff28a5.jpg",alt:"img"}})]),v._v(" "),s("h3",{attrs:{id:"混合使用aof日志和rdb的解决方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#混合使用aof日志和rdb的解决方案"}},[v._v("#")]),v._v(" 混合使用AOF日志和RDB的解决方案")]),v._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),s("p",[v._v("前一节提到AOF日志记录所有操作记录，但"),s("code",[v._v("有了RDB快照能力后")]),v._v("，"),s("code",[v._v("AOF就不用记录所有操作了")]),v._v("，只需要"),s("code",[v._v("记录增量记录即可")]),v._v("，记录量就小了。")]),v._v(" "),s("p",[v._v("若要恢复数据，可用RDB文件再加上AOF日志就可以全量恢复数据了。")]),v._v(" "),s("p",[v._v("在速度上，因为"),s("code",[v._v("RDB是二进制数据流")]),v._v("，可以"),s("code",[v._v("快速恢复出redis数据")]),v._v("，然后在此基础上"),s("code",[v._v("小量的执行AOF操作命令")]),v._v("，相比于只用AOF来恢复全量数据的操作，也不会太多影响到恢复速度。")])]),v._v(" "),s("p",[v._v("如下图所示，T1 和 T2 时刻的修改，用 AOF 日志记录，等到第二次做全量快照时，就可以清空 AOF 日志，因为此时的修改都已经记录到快照中了，恢复时就不再用日志了。")]),v._v(" "),s("p",[s("img",{attrs:{src:"/redis/base/e4c5846616c19fe03dbf528437beb320.jpg",alt:"img"}})])])}),[],!1,null,null,null);_.default=t.exports}}]);