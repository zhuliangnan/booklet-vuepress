(window.webpackJsonp=window.webpackJsonp||[]).push([[91],{560:function(v,_,t){"use strict";t.r(_);var c=t(7),s=Object(c.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"全局锁和表锁-给表加个字段怎么有这么多阻碍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#全局锁和表锁-给表加个字段怎么有这么多阻碍"}},[v._v("#")]),v._v(" 全局锁和表锁 ：给表加个字段怎么有这么多阻碍？")]),v._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),t("p",[v._v("数据库锁设计的初衷是"),t("code",[v._v("处理并发问题")]),v._v("。作为多用户共享的资源，当出现并发访问的时候，数据库需要"),t("code",[v._v("合理地控制资源")]),v._v("的访问规则")])]),v._v(" "),t("p",[v._v("根据"),t("code",[v._v("加锁的范围")]),v._v("，MySQL 里面的锁大致可以分成"),t("code",[v._v("全局锁")]),v._v("、"),t("code",[v._v("表级锁")]),v._v("和"),t("code",[v._v("行锁")]),v._v("三类")]),v._v(" "),t("h3",{attrs:{id:"全局锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#全局锁"}},[v._v("#")]),v._v(" 全局锁")]),v._v(" "),t("p",[v._v("MySQL 提供了一个"),t("code",[v._v("加全局读锁")]),v._v("的方法，命令是 "),t("code",[v._v("Flush tables with read lock (FTWRL)")]),v._v("。")]),v._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),t("p",[v._v("全局锁的"),t("code",[v._v("典型使用场景")]),v._v("是，做"),t("code",[v._v("全库逻辑备份")])])]),v._v(" "),t("p",[v._v("但是让整库都只读，听上去就很危险：")]),v._v(" "),t("div",{staticClass:"custom-block warning"},[t("p",{staticClass:"custom-block-title"},[v._v("WARNING")]),v._v(" "),t("p",[v._v("如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；")]),v._v(" "),t("p",[v._v("如果你在从库上备份，那么备份期间从库不能执行主库同步过来的 binlog，会导致主从延迟。")])]),v._v(" "),t("p",[v._v("那么备份期间为什么要加锁呢？我们来看一个场景")]),v._v(" "),t("p",[v._v("假设备份期间，有一个用户，他购买了一门课程，业务逻辑里就要扣掉他的余额，然后往已购课程里面加上一门课。")]),v._v(" "),t("p",[t("img",{attrs:{src:"/mysql/base/cbfd4a0bbb1210792064bcea4e49b0cd.png",alt:"img"}})]),v._v(" "),t("p",[v._v("可以看到由于备份两张表的延迟，导致用户白嫖了课程。当然如果反过来备份，会出现用户买了课程，钱扣了，课程也没有了。")]),v._v(" "),t("p",[v._v("解决：")]),v._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),t("p",[v._v("官方自带的逻辑备份工具是"),t("code",[v._v("mysqldump")]),v._v("。")]),v._v(" "),t("p",[v._v("当 "),t("code",[v._v("mysqldump")]),v._v(" 使用参数"),t("code",[v._v("–single-transaction")]),v._v(" 的时候，导数据之前就会启动一个"),t("code",[v._v("事务")]),v._v("，来确保拿到一致性视图。")]),v._v(" "),t("p",[v._v("而由于 MVCC 的支持，这个过程中数据是可以正常更新的。")]),v._v(" "),t("p",[v._v("看到这里我们发现可以使用事物中"),t("code",[v._v("可重复读")]),v._v("的事物隔离级别解决这个问题，为什么还需要 "),t("code",[v._v("FTWRL")]),v._v(" ，对于"),t("code",[v._v("MyISAM")]),v._v("并不支持事务,那么备份就只能通过 "),t("code",[v._v("FTWRL")]),v._v(" 方法")])]),v._v(" "),t("p",[v._v("既然需要全库只读，其实 "),t("code",[v._v("set global readonly=true")]),v._v(" 也是可以办到的。但是如果发生异常，"),t("code",[v._v("FTWRL")]),v._v(" 会自动"),t("code",[v._v("释放")]),v._v("这个全局锁。"),t("code",[v._v("readonly")]),v._v(" 会一直"),t("code",[v._v("保持 readonly")]),v._v(" 状态")]),v._v(" "),t("h3",{attrs:{id:"表级锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#表级锁"}},[v._v("#")]),v._v(" 表级锁")]),v._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),t("p",[v._v("MySQL 里面表级别的锁有两种：一种是"),t("code",[v._v("表锁")]),v._v("，一种是"),t("code",[v._v("元数据锁")]),v._v("。")])]),v._v(" "),t("h4",{attrs:{id:"表锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#表锁"}},[v._v("#")]),v._v(" 表锁")]),v._v(" "),t("div",{staticClass:"custom-block warning"},[t("p",{staticClass:"custom-block-title"},[v._v("WARNING")]),v._v(" "),t("p",[v._v("表锁的语法是 "),t("code",[v._v("lock tables … read/write")]),v._v(",可以用 "),t("code",[v._v("unlock tables")]),v._v(" 主动释放锁，也可以在客户端断开的时候自动释放")]),v._v(" "),t("p",[v._v("对表加读锁后，自己也不能对其进行修改；自己和其他线程只能读取该表。")]),v._v(" "),t("p",[v._v("当对某个表执加上"),t("code",[v._v("写锁")]),v._v("后（lock table t2 write），"),t("code",[v._v("该线程可以对这个表进行读写")]),v._v("，"),t("code",[v._v("其他线程对该表的读和写都受到阻塞")]),v._v("；")]),v._v(" "),t("p",[v._v("该线程此时也不能"),t("code",[v._v("读写其他未加锁的表")])])]),v._v(" "),t("p",[v._v("举个栗子, 如果在某个线程 A 中执行 lock tables t1 read, t2 write;  "),t("code",[v._v("t1读锁，t2写锁")])]),v._v(" "),t("p",[v._v("这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。")]),v._v(" "),t("p",[v._v("同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表。")]),v._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),t("p",[v._v("对于 InnoDB 这种支持行锁的引擎，一般不使用 lock tables 命令(表锁)来控制并发，毕竟锁住整个表的影响面还是太大。")])]),v._v(" "),t("h4",{attrs:{id:"元数据锁-mdl"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#元数据锁-mdl"}},[v._v("#")]),v._v(" 元数据锁(MDL)")]),v._v(" "),t("div",{staticClass:"custom-block warning"},[t("p",{staticClass:"custom-block-title"},[v._v("WARNING")]),v._v(" "),t("p",[v._v("MDL 不需要显式使用，系统默认会加, 在访问一个表的时候会被自动加上")]),v._v(" "),t("p",[t("strong",[t("code",[v._v("事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。")])])]),v._v(" "),t("p",[t("strong",[v._v("MDL 的作用是"),t("code",[v._v("隔离DML（Data Manipulation Language，数据操纵语言，如select,update,delete,insert）和DDL（Data Definition Language，数据定义语言，如改表头新增一列）操作之间的干扰")])]),v._v("，"),t("code",[v._v("保证读写的正确性")]),v._v("。你可以想象一下，如果一个"),t("code",[v._v("查询正在遍历一个表中的数据")]),v._v("，而执行期间另一个线程对这个"),t("code",[v._v("表结构做变更")]),v._v("，"),t("code",[v._v("删了一列")]),v._v("，那么查询线程拿到的结果跟表结构"),t("code",[v._v("对不上")]),v._v("，肯定是不行的。")]),v._v(" "),t("p",[v._v("在 MySQL 5.5 版本中引入了 MDL，当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。")]),v._v(" "),t("p",[t("code",[v._v("加读锁")]),v._v("则所有线程可正常"),t("code",[v._v("读元数据")]),v._v("，"),t("code",[v._v("不影响增删改查操作，只是不能修改表结构")]),v._v("；")]),v._v(" "),t("p",[t("code",[v._v("加写锁")]),v._v("则只有"),t("code",[v._v("拥有锁的线程可以读写元数据")]),v._v("，也就是"),t("code",[v._v("修改表结构")]),v._v("，其它线程不能执行任何操作，包括"),t("code",[v._v("修改表结构")]),v._v("与"),t("code",[v._v("增删改查")]),v._v("。")]),v._v(" "),t("p",[t("strong",[v._v("读读共享，读写互斥，写写互斥")])])]),v._v(" "),t("h3",{attrs:{id:"探讨-给一个小表加个字段-导致整个库挂了。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#探讨-给一个小表加个字段-导致整个库挂了。"}},[v._v("#")]),v._v(" 探讨:给一个小表加个字段，导致整个库挂了。")]),v._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),t("p",[v._v("给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据")]),v._v(" "),t("p",[v._v("索引要根据表中的每一行的记录值来创建，所以需要全表扫描；")]),v._v(" "),t("p",[v._v("加字段或修改字段，也要修改每一行记录中的对应列的数据，所以也要全表扫描")])]),v._v(" "),t("p",[v._v("假设表 t 是一个小表。")]),v._v(" "),t("p",[t("img",{attrs:{src:"/mysql/base/7cf6a3bf90d72d1f0fc156ececdfb0ce.jpg",alt:"img"}})]),v._v(" "),t("ol",[t("li",[v._v("我们可以看到 "),t("code",[v._v("session A")]),v._v(" 先启动，这时候会对表 t 加一个 MDL "),t("code",[v._v("读锁")]),v._v("。由于 "),t("code",[v._v("session B")]),v._v(" 需要的也是 MDL "),t("code",[v._v("读锁")]),v._v("，因此可以正常执行。")]),v._v(" "),t("li",[v._v("之后 "),t("code",[v._v("session C")]),v._v(" 会被 "),t("code",[v._v("blocked")]),v._v("，是因为 "),t("code",[v._v("session A")]),v._v(" 的 MDL 读锁还"),t("code",[v._v("没有释放(即A事务没有commit)")]),v._v("，而 "),t("code",[v._v("session C")]),v._v(" 需要 MDL "),t("code",[v._v("写锁")]),v._v("，因此只能被"),t("code",[v._v("blocked")]),v._v("。")]),v._v(" "),t("li",[v._v("如果只有 "),t("code",[v._v("session C")]),v._v(" 自己被阻塞还没什么关系，但是之后所有要在表 t 上"),t("code",[v._v("新申请")]),v._v(" MDL "),t("code",[v._v("读锁")]),v._v("的请求也会被 "),t("code",[v._v("session C 阻塞")]),v._v("。前面我们说了，所有对表的增删改查操作都需要先申请 MDL 读锁，就都被锁住，等于这个表现在"),t("code",[v._v("完全不可读写了")]),v._v("。")]),v._v(" "),t("li",[v._v("如果某个表上"),t("code",[v._v("的查询语句频繁")]),v._v("，而且客户端有"),t("code",[v._v("重试机制")]),v._v("，也就是说"),t("code",[v._v("超时后会再起一个新 session")]),v._v(" 再请求的话，这个库的"),t("code",[v._v("线程很快就会爆满")]),v._v("。")])]),v._v(" "),t("p",[v._v("解决：")]),v._v(" "),t("ul",[t("li",[v._v("首先我们要解决长事务，事务不提交，就会一直占着 MDL 锁，"),t("code",[v._v("information_schema")]),v._v(" 库的 "),t("code",[v._v("innodb_trx")]),v._v(" 表中，你可以查到"),t("code",[v._v("当前执行中的事务")]),v._v("。如果你要做 DDL 变更的表刚好有长事务在执行，要考虑先暂停 DDL，或者 kill 掉这个长事务。")]),v._v(" "),t("li",[v._v("小表，数据量不高，可以重复通过"),t("code",[v._v("过时时间不断尝试获取MDL")]),v._v("锁来去执行"),t("code",[v._v("ddl")]),v._v(" 语句，因为即使扫描全部数据也用不了多少时间。")])])])}),[],!1,null,null,null);_.default=s.exports}}]);