(window.webpackJsonp=window.webpackJsonp||[]).push([[125],{475:function(_,v,e){"use strict";e.r(v);var c=e(7),s=Object(c.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h2",{attrs:{id:"主从机制-主从库如何实现数据一致"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#主从机制-主从库如何实现数据一致"}},[_._v("#")]),_._v(" 主从机制：主从库如何实现数据一致？")]),_._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[_._v("TIP")]),_._v(" "),e("p",[_._v("Redis 提供了主从库模式，以保证数据副本的一致，"),e("code",[_._v("主从库")]),_._v("之间采用的是"),e("code",[_._v("读写分离")]),_._v("的方式。")]),_._v(" "),e("p",[e("code",[_._v("读操作")]),_._v("：主库、从库都可以接收；")]),_._v(" "),e("p",[e("code",[_._v("写操作")]),_._v("：首先到主库执行，然后，主库将写操作"),e("code",[_._v("同步")]),_._v("给从库。")])]),_._v(" "),e("p",[_._v("Redis主从库和读写分离")]),_._v(" "),e("p",[e("img",{attrs:{src:"/redis/base/809d6707404731f7e493b832aa573a2f.jpg",alt:"img"}})]),_._v(" "),e("h3",{attrs:{id:"主从库间如何进行第一次同步"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#主从库间如何进行第一次同步"}},[_._v("#")]),_._v(" 主从库间如何进行第一次同步？")]),_._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[_._v("TIP")]),_._v(" "),e("p",[_._v("当我们启动多个 Redis 实例的时候，它们相互之间就可以通过 replicaof（Redis 5.0 之前使用 slaveof）命令形成主库和从库的关系，之后会按照三个阶段完成数据的第一次同步。")])]),_._v(" "),e("p",[_._v("例如，现在有实例 1（ip：172.16.19.3）和实例 2（ip：172.16.19.5），我们在实例 2 上执行以下这个命令后，"),e("code",[_._v("实例2")]),_._v(" 就变成了"),e("code",[_._v("实例1")]),_._v("的"),e("code",[_._v("从库")]),_._v("，并从实例 1 上复制数据：")]),_._v(" "),e("div",{staticClass:"language-css extra-class"},[e("pre",{pre:!0,attrs:{class:"language-css"}},[e("code",[_._v("replicaof 172.16.19.3 6379\n")])])]),e("p",[_._v("主从库间数据第一次同步的三个阶段")]),_._v(" "),e("p",[e("img",{attrs:{src:"/redis/base/63d18fd41efc9635e7e9105ce1c33da1.jpg",alt:"img"}})]),_._v(" "),e("p",[_._v("解释：")]),_._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[_._v("TIP")]),_._v(" "),e("p",[_._v("第一阶段是主从库间"),e("code",[_._v("建立连接")]),_._v("、"),e("code",[_._v("协商同步")]),_._v("的过程，主要是为全量复制做准备。从库给主库发送 psync 命令，表示要进行数据同步，主库根据这个命令的参数来启动复制")])]),_._v(" "),e("p",[_._v("psync 命令包含了主库的 runID 和复制进度 offset 两个参数。")]),_._v(" "),e("ul",[e("li",[_._v("runID，是每个 Redis 实例启动时都会自动生成的一个"),e("code",[_._v("随机 ID")]),_._v("，用来"),e("code",[_._v("唯一标记这个实例")]),_._v("。当从库和主库第一次复制时，因为不知道主库的 runID，所以将 runID 设为“？”。")]),_._v(" "),e("li",[_._v("offset，此时设为 -1，表示第一次复制。")])]),_._v(" "),e("p",[_._v("主库收到 psync 命令后，会用 FULLRESYNC 响应命令带上两个参数："),e("code",[_._v("主库 runID")]),_._v(" 和主库目前的"),e("code",[_._v("复制进度 offset")]),_._v("，返回给从库。从库收到响应后，会记录下这两个参数。")]),_._v(" "),e("p",[_._v("FULLRESYNC 响应表示第一次复制采用的全量复制，也就是说，主库会把当前"),e("code",[_._v("所有的数据")]),_._v("都复制给从库。")]),_._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[_._v("TIP")]),_._v(" "),e("p",[_._v("第二阶段，主库将所有"),e("code",[_._v("数据同步")]),_._v("给从库。从库收到数据后，在本地完成数据加载。这个过程依赖于内存快照生成的"),e("code",[_._v("RDB 文件")]),_._v("。")])]),_._v(" "),e("p",[e("code",[_._v("具体来说")]),_._v("，主库执行"),e("code",[_._v("bgsave 命令")]),_._v("，"),e("code",[_._v("生成 RDB 文件")]),_._v("，接着将文件发给从库。")]),_._v(" "),e("p",[_._v("从库接收到 RDB 文件后，会先"),e("code",[_._v("清空当前数据库")]),_._v("，然后加载 RDB 文件。这是因为从库在通过 replicaof 命令开始和主库同步前，"),e("code",[_._v("可能保存了其他数据")]),_._v("。为了"),e("code",[_._v("避免")]),_._v("之前数据的"),e("code",[_._v("影响")]),_._v("，"),e("code",[_._v("从库需要")]),_._v("先把当前数据库"),e("code",[_._v("清空")]),_._v("。")]),_._v(" "),e("p",[_._v("在主库将数据同步给从库的过程中，"),e("code",[_._v("主库不会被阻塞")]),_._v("，仍然可以正常接收请求。否则，Redis 的服务就被中断了。"),e("code",[_._v("但是")]),_._v("，这些请求中的"),e("code",[_._v("写操作并没有记录")]),_._v("到刚刚生成的 RDB 文件中。"),e("code",[_._v("为了保证主从库的数据一致性")]),_._v("，主库会在内存中用"),e("code",[_._v("专门的 replication buffer，记录 RDB 文件生成后收到的所有写操作")]),_._v("。")]),_._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[_._v("TIP")]),_._v(" "),e("p",[_._v("第三个阶段，主库会把"),e("code",[_._v("第二阶段")]),_._v("执行过程中"),e("code",[_._v("新收到的写命令")]),_._v("，再"),e("code",[_._v("发送给从库")]),_._v("。")])]),_._v(" "),e("p",[e("code",[_._v("具体的操作是")]),_._v("，当主库完成 RDB 文件发送后，就会把此时 "),e("code",[_._v("replication buffer")]),_._v(" 中的修改操作发给从库，"),e("code",[_._v("从库")]),_._v("再"),e("code",[_._v("重新执行这些操作")]),_._v("。这样一来，"),e("code",[_._v("主从库就实现同步了")]),_._v("。")]),_._v(" "),e("h3",{attrs:{id:"主从级联模式分担全量复制时的主库压力-主-从-从-模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#主从级联模式分担全量复制时的主库压力-主-从-从-模式"}},[_._v("#")]),_._v(" 主从级联模式分担全量复制时的主库压力(“主-从-从”模式)")]),_._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[_._v("TIP")]),_._v(" "),e("p",[_._v("一次全量复制中，对于主库来说，需要完成两个耗时的操作：生成 RDB 文件和传输 RDB 文件")]),_._v(" "),e("p",[_._v("如果从库数量很多，而且都要和主库进行全量复制的话，就会导致主库忙于 fork 子进程生成 RDB 文件，进行数据全量同步。")]),_._v(" "),e("p",[_._v("fork 这个操作会阻塞主线程处理正常请求，从而导致主库响应应用程序的请求速度变慢。此外，传输 RDB 文件也会占用主库的网络带宽，同样会给主库的资源使用带来压力。")]),_._v(" "),e("p",[_._v("那么，有没有好的解决方法可以分担主库压力呢？其实是有的，这就是“主 - 从 - 从”模式。")])]),_._v(" "),e("p",[_._v("简单来说，我们在部署主从集群的时候，可以手动选择一个"),e("code",[_._v("从库")]),_._v("（比如选择内存资源配置较高的从库），"),e("code",[_._v("用于级联其他的从库")]),_._v("。然后，我们可以再选择一些从库（例如三分之一的从库），在这些从库上执行如下命令，让它们和刚才所选的从库，建立起主从关系。")]),_._v(" "),e("div",{staticClass:"language-css extra-class"},[e("pre",{pre:!0,attrs:{class:"language-css"}},[e("code",[_._v("replicaof 所选从库的IP 6379\n")])])]),e("p",[_._v("这样一来，这些从库就会知道，在"),e("code",[_._v("进行同步时")]),_._v("，"),e("code",[_._v("不用再和主库进行交互了")]),_._v("，只要"),e("code",[_._v("和级联的从库进行写操作同步就行了")]),_._v("，这就可以"),e("code",[_._v("减轻主库上的压力")]),_._v("，如下图所示：")]),_._v(" "),e("p",[e("img",{attrs:{src:"/redis/base/403c2ab725dca8d44439f8994959af45.jpg",alt:"img"}})]),_._v(" "),e("p",[_._v("那么，一旦主从库完成了全量复制，它们之间就会一直维护"),e("code",[_._v("一个网络连接，")]),_._v("主库会通过这个"),e("code",[_._v("连接")]),_._v("将后续陆续收到的命令操作再"),e("code",[_._v("同步给从库")]),_._v("，这个过程也称为基于"),e("code",[_._v("长连接的命令传播")]),_._v("，可以"),e("code",[_._v("避免频繁建立连接的开销")]),_._v("。")]),_._v(" "),e("h3",{attrs:{id:"主从库间网络断了怎么办-增量复制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#主从库间网络断了怎么办-增量复制"}},[_._v("#")]),_._v(" 主从库间网络断了怎么办？(增量复制)")]),_._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[_._v("TIP")]),_._v(" "),e("p",[_._v("如果网络断连，主从库之间就无法进行命令传播了，从库的数据自然也就没办法和主库保持一致了，客户端就可能从从库读到旧数据。")]),_._v(" "),e("p",[_._v("在 Redis 2.8 之前，如果主从库在命令传播时出现了网络闪断，那么，从库就会和主库重新进行一次全量复制，开销非常大。")]),_._v(" "),e("p",[_._v("从 Redis 2.8 开始，网络断了之后，主从库会采用"),e("code",[_._v("增量复制")]),_._v("的方式继续同步，增量复制只会把主从库"),e("code",[_._v("网络断连期间主库收到的命令")]),_._v("，"),e("code",[_._v("同步")]),_._v("给从库")])]),_._v(" "),e("p",[_._v("增量复制时，主从库之间具体是怎么保持同步的呢？这里的奥妙就在于"),e("code",[_._v("repl_backlog_buffer")]),_._v("这个缓冲区")]),_._v(" "),e("p",[e("code",[_._v("repl_backlog_buffer")]),_._v(" 是一个"),e("code",[_._v("环形缓冲区")]),_._v("，"),e("code",[_._v("主库会记录自己写到的位置，从库则会记录自己已经读到的位置")])]),_._v(" "),e("p",[_._v("刚开始的时候，主库和从库的写读位置在一起，这算是它们的"),e("code",[_._v("起始位置")]),_._v("。随着主库不断接收新的写操作，它在缓冲区中的写位置会逐步偏离起始位置，我们通常用"),e("code",[_._v("偏移量")]),_._v("来衡量这个偏移距离的大小，对主库来说，对应的偏移量就是"),e("code",[_._v("master_repl_offset")]),_._v("。主库接收的"),e("code",[_._v("新写操作越多，这个值就会越大")]),_._v("。")]),_._v(" "),e("p",[_._v("同样，从库在复制完写操作命令后，它在缓冲区中的读位置也开始"),e("code",[_._v("逐步偏移刚才的起始位置")]),_._v("，此时，从库已复制的偏移量 "),e("code",[_._v("slave_repl_offset")]),_._v(" 也在不断增加。正常情况下，这两个偏移量基本相等。")]),_._v(" "),e("p",[e("img",{attrs:{src:"/redis/base/13f26570a1b90549e6171ea24554b737.jpg",alt:"img"}})]),_._v(" "),e("p",[_._v("主从库的连接恢复之后，"),e("code",[_._v("从库")]),_._v("首先会给"),e("code",[_._v("主库发送 psync 命令")]),_._v("，并把自己当前的 "),e("code",[_._v("slave_repl_offset 发给主库")]),_._v("，主库会判断自己的 "),e("code",[_._v("master_repl_offset 和 slave_repl_offset 之间的差距。")]),_._v("主库只需要把它们同步给从库，就行了。")]),_._v(" "),e("p",[_._v("从库会心跳给主库上报 自己复制到哪了")]),_._v(" "),e("p",[_._v("Redis增量复制过程")]),_._v(" "),e("p",[e("img",{attrs:{src:"/redis/base/20e233bd30c3dacb0221yy0c77780b16.jpg",alt:"img"}})]),_._v(" "),e("p",[e("code",[_._v("问题")]),_._v("：因为 "),e("code",[_._v("repl_backlog_buffer")]),_._v("是一个环形缓冲区，所以在"),e("code",[_._v("缓冲区写满后，主库会继续写入")]),_._v("，此时，就会"),e("code",[_._v("覆盖掉之前写入的操作")]),_._v("。如果"),e("code",[_._v("从库")]),_._v("的"),e("code",[_._v("读取速度比较慢")]),_._v("，就有"),e("code",[_._v("可能导致从库还未读取的操作被主库新写的操作覆盖了")]),_._v("，这会导致主从库间的数据不一致。")]),_._v(" "),e("p",[e("code",[_._v("解决")]),_._v("：调整 "),e("code",[_._v("repl_backlog_size")]),_._v(" 这个参数。这个参数和所需的缓冲空间大小有关。")]),_._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[_._v("TIP")]),_._v(" "),e("p",[_._v("缓冲空间的计算公式是：缓冲空间大小 = 主库写入命令速度 * 操作大小 - 主从库间网络传输命令速度 * 操作大小")]),_._v(" "),e("p",[_._v("在实际应用中，考虑到可能存在一些突发的请求压力，我们通常需要把这个缓冲空间扩大一倍，即 repl_backlog_size = 缓冲空间大小 * 2，这也就是 "),e("code",[_._v("repl_backlog_size 的最终值")]),_._v("。")]),_._v(" "),e("p",[_._v("举个例子，如果主库每秒写入 2000 个操作，每个操作的大小为 2KB，网络每秒能传输 1000 个操作，那么，有 1000 个操作需要缓冲起来，这就至少需要 2MB 的缓冲空间。否则，新写的命令就会覆盖掉旧操作了。为了应对可能的突发压力，我们最终把 repl_backlog_size 设为 4MB。")]),_._v(" "),e("p",[e("code",[_._v("极端情况")]),_._v("：如果从库断开时间太久，repl_backlog_buffer环形缓冲区被主库的写命令覆盖了，那么从库连上主库后只能乖乖地进行"),e("code",[_._v("一次全量同步")]),_._v("，所以"),e("code",[_._v("repl_backlog_buffer")]),_._v("配置尽量大一些，可以降低主从断开后全量同步的概率")])]),_._v(" "),e("h3",{attrs:{id:"提问-主从全量同步使用rdb而不使用aof的原因"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#提问-主从全量同步使用rdb而不使用aof的原因"}},[_._v("#")]),_._v(" 提问：主从全量同步使用RDB而不使用AOF的原因")]),_._v(" "),e("ol",[e("li",[e("code",[_._v("RDB文件内容")]),_._v("是经过压缩的"),e("code",[_._v("二进制数据")]),_._v("（不同数据类型数据做了针对性优化），"),e("code",[_._v("文件很小")]),_._v("。而"),e("code",[_._v("AOF文件")]),_._v("记录的是"),e("code",[_._v("每一次写操作的命令")]),_._v("，"),e("code",[_._v("写操作越多文件会变得很大")]),_._v("，其中"),e("code",[_._v("还包括")]),_._v("很多"),e("code",[_._v("对同一个key的多次冗余操作")]),_._v("。在"),e("code",[_._v("主从全量数据同步")]),_._v("时，"),e("code",[_._v("传输RDB文件可以尽量降低对主库机器网络带宽的消耗")]),_._v("，从库在加载RDB文件时，一是文件小，读取整个文件的速度会很快，二是因为RDB文件存储的都是二进制数据，从库直接按照RDB协议解析还原数据即可，速度会非常快，而AOF需要依次重放每个写命令，这个过程会经历冗长的处理逻辑，恢复速度相比RDB会慢得多，所以使用RDB进行主从全量同步的成本最低。")]),_._v(" "),e("li",[e("code",[_._v("假设要使用AOF做全量同步")]),_._v("，意味着必须"),e("code",[_._v("打开AOF功能")]),_._v("，打开AOF就要选择"),e("code",[_._v("文件刷盘的策略")]),_._v("，"),e("code",[_._v("选择不当会严重影响Redis性能")]),_._v("。而RDB只有在需要"),e("code",[_._v("定时备份")]),_._v("和主从全量同步数据时"),e("code",[_._v("才会触发生成一次快照")]),_._v("。而在"),e("code",[_._v("很多丢失数据不敏感的业务场景，其实是不需要开启AOF的")]),_._v("。")])])])}),[],!1,null,null,null);v.default=s.exports}}]);