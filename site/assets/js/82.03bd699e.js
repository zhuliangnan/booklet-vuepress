(window.webpackJsonp=window.webpackJsonp||[]).push([[82],{481:function(n,_,v){"use strict";v.r(_);var e=v(7),l=Object(e.a)({},(function(){var n=this,_=n.$createElement,v=n._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[v("h2",{attrs:{id:"mysql篇"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mysql篇"}},[n._v("#")]),n._v(" MySql篇")]),n._v(" "),v("h3",{attrs:{id:"_1-mysql-索引使用有哪些注意事项呢"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-mysql-索引使用有哪些注意事项呢"}},[n._v("#")]),n._v(" 1. MySQL 索引使用有哪些注意事项呢？")]),n._v(" "),v("p",[n._v("索引哪些情况会失效")]),n._v(" "),v("ul",[v("li",[n._v("查询条件包含or，可能导致索引失效")]),n._v(" "),v("li",[n._v("字段类型不一致导致的索引失效")]),n._v(" "),v("li",[n._v("前导模糊查询不能使用索引。 select * fromdoc where title like '%XX'")]),n._v(" "),v("li",[n._v("联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。")]),n._v(" "),v("li",[n._v("在索引列上使用mysql的内置函数，索引失效。")]),n._v(" "),v("li",[n._v("对索引列运算（如 ，+、-、*、/），索引失效。")]),n._v(" "),v("li",[n._v("索引字段上使用（！= 或者 < >，not in）时，可能会导致索引失效。")]),n._v(" "),v("li",[n._v("索引字段上使用is null， is not null，可能导致索引失效。")]),n._v(" "),v("li",[n._v("左连接查询或者右连接查询查询关联的字段编码格式不一样，可能导致索引失效。")]),n._v(" "),v("li",[n._v("mysql估计使用全表扫描要比使用索引快,则不使用索引。")]),n._v(" "),v("li",[n._v("左连接索引失效因为左连接是左边查所有，也就是a表查所有")])]),n._v(" "),v("p",[n._v("索引不适合哪些场景\n数据量少的不适合加索引\n更新比较频繁的也不适合加索引\n区分度低的字段不适合加索引（如性别）")]),n._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[n._v("日常工作中你是怎么优化SQL的？\n加索引\n避免返回不必要的数据\n利用延迟关联或者子查询优化超多分页场景。\n备注：MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写。\n延迟关联：通过使用覆盖索引查询返回需要的主键,再根据主键关联原表获得需要的数据")])]),n._v(" "),v("p",[n._v("子查询示例如下，先快速定位需要获取的 id 段，然后再关联:\nselect a.* from 表1 a,(select id from 表1 where 条件 limit 100000,20 ) b where a.id=b.id\n超过三个表最好不要 join。因为mysql的联表查询很弱，解决方案：可以在建表的时候做冗余，放在一个表，或者分表查询，程序端(java)做数据处理\n分库分表\n水平分库：以字段为依据，按照一定策略（hash、range等），将一个库中的数据拆分到多个库中。\n水平分表：以字段为依据，按照一定策略（hash、range等），将一个表中的数据拆分到多个表中。\n垂直分库：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。\n垂直分表：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中。")]),n._v(" "),v("p",[n._v("备注：分库分表可能存在的问题\n事务问题：需要用分布式事务啦\n跨节点Join的问题：解决这一问题可以分两次查询实现\n跨节点的count,order by,group by以及聚合函数问题：分别在各个节点上得到结果后在应用程序端进行合并。\n数据迁移，容量规划，扩容等问题\n读写分离")]),n._v(" "),v("p",[n._v("2.1 SQL优化的一般步骤是什么，怎么看执行计划（explain），如何理解其中各个字段的含义。\nshow status 命令了解各种 sql 的执行频率,如下")]),n._v(" "),v("p",[n._v("通过慢查询日志定位那些执行效率较低的 sql 语句")]),n._v(" "),v("p",[n._v("explain 分析低效 sql 的执行计划（这点非常重要，日常开发中用它分析Sql，会大大降低Sql导致的线上事故）\n关于Explain命令的简单介绍")]),n._v(" "),v("p",[n._v("id:选择标识符\nselect_type: 表示查询的类型。\ntable: 输出结果集的表\npartitions: 匹配的分区\ntype: 表示表的连接类型\npossible_keys: 表示查询时，可能使用的索引\nkey: 表示实际使用的索引\nkey_len: 索引字段的长度\nref: 列与索引的比较\nrows: 扫描出的行数(估算的行数)\nfiltered: 按表条件过滤的行百分比\nExtra: 执行情况的描述和说明")]),n._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[n._v("InnoDB与MyISAM的区别\nInnoDB支持事务，MyISAM不支持事务\nInnoDB支持外键，MyISAM不支持外键\nInnoDB支持表、行级锁，而MyISAM支持表级锁。")])]),n._v(" "),v("p",[n._v("4.数据库索引的原理，为什么要用 B+树，为什么不用二叉树？")]),n._v(" "),v("p",[n._v("可以从几个维度去看这个问题，查询是否够快，效率是否稳定，存储数据多少，以及查找磁盘次数，为什么不是二叉树，为什么不是平衡二叉树，为什么不是B树，而偏偏是B+树呢？")]),n._v(" "),v("p",[n._v("为什么不是一般二叉树？\n如果二叉树特殊化为一个链表，相当于全表扫描")]),n._v(" "),v("p",[n._v("为什么不是平衡二叉树呢？\n在内存比在磁盘的数据，查询效率快得多。如果树这种数据结构作为索引，那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块，但是平衡二叉树可是每个节点只存储一个键值和数据的")]),n._v(" "),v("p",[n._v("那为什么不是B树而是B+树呢？\nB+树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据，会读取很多不必要的数据。innodb中页的默认大小是16KB，如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。\nB+树的叶子节点有一条链相连，而B+树的叶子节点各自独立")]),n._v(" "),v("p",[n._v("B+树的叶节点由一条链相连")]),n._v(" "),v("p",[n._v("由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键\nB+树的叶节点由一条链相连")]),n._v(" "),v("p",[n._v("5.. 聚集索引与非聚集索引的区别")]),n._v(" "),v("p",[n._v("聚集索引：\n数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引。索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块，还得进行二次查询，所以查询速度来说聚集索引快")]),n._v(" "),v("p",[n._v("非聚集索引(包括，普通索引,全文索引，唯一索引，全文索引，组合索引)：\n索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同")]),n._v(" "),v("ol",{attrs:{start:"6"}},[v("li",[v("p",[n._v("limit 1000000,10 加载很慢的话，你是怎么解决的呢\n方案一：如果id是连续的，可以这样，返回上次查询的最大记录(偏移量)，再往下limit\nselect id，name from employee where id>1000000 limit 10.\n方案二：order by + 索引（id为索引）\nselect id，name from employee order by id  limit 1000000，10\n方案三：利用延迟关联或者子查询优化超多分页场景\nselect a.* from employee a, (select id from employee where 条件 LIMIT 1000000,10 ) b where a.id=b.id")])]),n._v(" "),v("li",[v("p",[n._v("如何选择合适的分布式主键方案呢？\nUUID。\nRedis生成ID\n利用zookeeper生成唯一ID")])])]),n._v(" "),v("p",[n._v("8.事务的隔离级别有哪些\n读未提交 ：读到其他事务未提交的数据的，即存在脏读问题\n读已提交 ：就是事务要等另一个事物提交后才能读取数据 解决脏读，但是有可能A事务没有提交，B事务就已经更改了并且提交了。会导致  不可重复读(针对的是更新)---同一事务内，不同的时刻读到的同一批数据可能是不一样的\n可重复读(Mysql默认)：就是在开始读取数据（事物开启）时，不再允许修改操作。但是可能会有会有幻读(针对的是新增)--A在修改，B插入了一条数据，A修改完在读取发现多了一条，好像出现幻觉\n串行化 ：将事务的执行变为顺序执行")]),n._v(" "),v("p",[n._v("9.在高并发情况下，如何做到安全的修改同一行数据？悲观锁和乐观锁\n1.使用悲观锁思想就是，当前线程要进来修改数据时，别的线程都得拒之门外~ 比如，可以使用select…for update ~")]),n._v(" "),v("p",[n._v("2.使用乐观锁，一般会使用版本号机制或CAS算法实现。")]),n._v(" "),v("p",[n._v("10.MySQL事务得四大特性")]),n._v(" "),v("p",[n._v("原子性： 事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。\n一致性： 指在事务开始之前和事务结束以后，数据不会被破坏，假如A账户给B账户转10块钱，不管成功与否，A和B的总金额是不变的。\n隔离性： 多个事务并发访问时，事务之间是相互隔离的，即一个事务不影响其它事务运行效果。简言之，就是事务之间是进水不犯河水的。\n持久性： 表示事务完成以后，该事务对数据库所作的操作更改，将持久地保存在数据库之中。\n11. mysql中in 和exists的区别")]),n._v(" "),v("p",[n._v("in先做子查询，在执行主查询\nexists查询的理解就是，先执行主查询，获得数据后，再放到子查询中做条件验证，根据验证结果（true或者false），来决定主查询的数据结果是否得意保留。")]),n._v(" "),v("p",[n._v("因此，我们要选择最外层循环小的，也就是，如果B的数据量小于A，适合使用in，如果B的数据量大于A，即适合选择exists，这就是in和exists的区别。")]),n._v(" "),v("ol",{attrs:{start:"12"}},[v("li",[n._v("MYSQL的主从延迟，你怎么解决？\n主从复制分了五个步骤进行：\n步骤一：主库的更新事件(update、insert、delete)被写到binlog\n步骤二：从库发起连接，连接到主库。\n步骤三：此时主库创建一个binlog线程，把binlog的内容发送到从库。\n步骤四：从库启动之后，创建一个I/O线程，读取主库传过来的binlog内容并写入到relay log\n步骤五：还会创建一个SQL执行线程，从relay-log里面读取内容，从Exec_Master_Log_Pos位置开始执行读取到的更新事件，将更新内容写入到slave的db")])]),n._v(" "),v("p",[n._v("主从同步延迟的原因\n从服务器的里面读取binlog的线程仅有一个，当某个SQL在从服务器上执行的时间稍长 或者由于某个SQL要进行锁表就会导致，主服务器的SQL大量积压，未被同步到从服务器里。这就导致了主从不一致， 也就是主从延迟。")]),n._v(" "),v("p",[n._v("解决：\n增加从服务器喽，这个目的还是分散读的压力，从而降低服务器负载。")]),n._v(" "),v("p",[n._v("13.说一下大表查询的优化方案\n可以考虑加缓存, redis，或者JVM本地缓存；\n主从复制，读写分离；\n分库分表；")]),n._v(" "),v("p",[n._v("14.InnoDB引擎中的索引策略，了解过吗？\n覆盖索引  -- 只需要通过索引就可以返回数据，索引叶子节点存储了它们索引的数据，当能通过读取索引就可以得到想要的数据\n最左前缀原则\n索引下推\n索引下推优化是 MySQL 5.6 引入的， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。")]),n._v(" "),v("p",[n._v("什么是回表？\n简单来说就是数据库根据索引（非主键）找到了指定的记录所在行后，还需要根据主键再次到数据块里获取数据。")]),n._v(" "),v("ol",{attrs:{start:"15"}},[v("li",[n._v("从锁的类别角度讲，MySQL都有哪些锁呢？")])]),n._v(" "),v("p",[n._v("共享锁: 又叫做读锁。当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。\n排他锁: 又叫做写锁。当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。")]),n._v(" "),v("p",[n._v("16.MySQL中InnoDB引擎的行锁是怎么实现的？")]),n._v(" "),v("p",[n._v("基于索引来完成行锁的。")]),n._v(" "),v("p",[n._v("for update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id 不是索引键那么InnoDB将实行表锁。")]),n._v(" "),v("ol",{attrs:{start:"17"}},[v("li",[n._v("视图有哪些特点？哪些使用场景？")])]),n._v(" "),v("p",[n._v("视图是一个虚拟的表,列可以来自不同的表,对视图内容的更新(添加，删除和修改)直接影响基本表。也不允许删除和修改， 简化sql查询，提高开发效率")]),n._v(" "),v("p",[n._v("18.. count(1)、count(*) 与 count(列名) 的区别？")]),n._v(" "),v("p",[n._v("count(*)包括了所有的列，不忽略列值为NULL\ncount(1)用1代表代码行，在统计结果的时候，不忽略列值为NULL\ncount(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空")]),n._v(" "),v("p",[n._v("19.什么是存储过程？有哪些优缺\n优点：存储过程是一个预编译的代码块，执行效率比较高\n缺点：\n调试麻烦\n可移植性不灵活\n重新编译问题")]),n._v(" "),v("p",[n._v("20.UNION与UNION ALL的区别？\nUnion：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序；\nUnion All：对两个结果集进行并集操作，包括重复行，不进行排序；\nUNION的效率高于 UNION ALL")]),n._v(" "),v("p",[n._v("21.读写分离常见方案？")]),n._v(" "),v("p",[n._v("应用程序根据业务逻辑来判断，增删改等写操作命令发给主库，查询命令发给备库。\n利用中间件来做代理，负责对数据库的请求识别出读还是写，并分发到不同的数据库中。（如：amoeba，mysql-proxy）")]),n._v(" "),v("p",[n._v("22.Innodb的事务实现原理？\n原子性：是使用 undo log来实现的，如果事务执行过程中出错或者用户执行了rollback，系统通过undo log日志返回事务开始的状态。\n持久性：使用 redo log来实现，只要redo log日志持久化了，当系统崩溃，即可通过redo log把数据恢复。\n隔离性：通过锁以及MVCC,使事务相互隔离开。\n一致性：通过回滚、恢复，以及并发情况下的隔离性，从而实现一致性。")]),n._v(" "),v("p",[n._v("https://juejin.cn/post/6913855924486537224")]),n._v(" "),v("p",[n._v("undo log ：\nundo log 是回滚日志，是记录每条数据的所有版本，比如 update 语句，那么它首先会将该条记录的数据记录到undo log日志中，并且将最新版本的roll_pointer指针指向上一个版本，这样就可以形成当前记录的所有版本，这也是MVCC的实现机制。")]),n._v(" "),v("p",[n._v("redo log ：\n具体的来说，就是当有一条记录需要更新的时候，InnoDB引擎会把记录优先更新到redo log（粉板）里面，并更新内存，这样更新操作就完成了。同时，InnoDB引擎会在空闲的时间将redo log中的记录存储到磁盘上。用于系统奔溃恢复")]),n._v(" "),v("p",[n._v("23.行锁，表锁，间隙锁，理解\n索引失效为什么行锁会升级成表锁？\n是因为行锁实现是加在索引上的 如过锁引失效 那么只能锁表来锁住资源了\nhttps://juejin.cn/post/6850037282720710669")])])}),[],!1,null,null,null);_.default=l.exports}}]);