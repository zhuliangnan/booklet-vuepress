(window.webpackJsonp=window.webpackJsonp||[]).push([[126],{503:function(v,_,s){"use strict";s.r(_);var e=s(7),t=Object(e.a)({},(function(){var v=this,_=v.$createElement,s=v._self._c||_;return s("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[s("h2",{attrs:{id:"切片集群-数据增多了-是该加内存还是加实例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#切片集群-数据增多了-是该加内存还是加实例"}},[v._v("#")]),v._v(" 切片集群：数据增多了，是该加内存还是加实例？")]),v._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),s("p",[v._v("切片集群，也叫分片集群，就是指启动多个 Redis 实例组成一个集群，然后按照一定的规则，把收到的数据划分成多份，每一份用一个实例来保存")])]),v._v(" "),s("p",[s("img",{attrs:{src:"/redis/base/793251ca784yyf6ac37fe46389094b26.jpg",alt:"img"}})]),v._v(" "),s("h3",{attrs:{id:"如何保存更多数据"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何保存更多数据"}},[v._v("#")]),v._v(" 如何保存更多数据？")]),v._v(" "),s("ul",[s("li",[s("code",[v._v("纵向扩展")]),v._v("："),s("code",[v._v("升级")]),v._v("单个 Redis 实例的"),s("code",[v._v("资源配置")]),v._v("，包括增加内存容量、增加磁盘容量、使用更高配置的 CPU。就像下图中，原来的实例内存是 8GB，硬盘是 50GB，纵向扩展后，内存增加到 24GB，磁盘增加到 150GB。")]),v._v(" "),s("li",[s("code",[v._v("横向扩展")]),v._v("：横向增加当前 Redis 实例的个数，就像下图中，原来使用 1 个 8GB 内存、50GB 磁盘的实例，现在使用三个相同配置的实例。")])]),v._v(" "),s("p",[s("img",{attrs:{src:"/redis/base/7a512fec7eba789c6d098b834929701a.jpg",alt:"img"}})]),v._v(" "),s("p",[v._v("在面向百万、千万级别的用户规模时，横向扩展的 Redis 切片集群会是一个非常好的选择。")]),v._v(" "),s("p",[s("code",[v._v("要想把切片集群用起来，我们就需要解决两大问题")]),v._v("：")]),v._v(" "),s("ol",[s("li",[v._v("数据切片后，在多个实例之间如何分布？")]),v._v(" "),s("li",[v._v("客户端怎么确定想要访问的数据在哪个实例上？")])]),v._v(" "),s("h3",{attrs:{id:"数据切片和实例的对应分布关系"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据切片和实例的对应分布关系"}},[v._v("#")]),v._v(" 数据切片和实例的对应分布关系")]),v._v(" "),s("h4",{attrs:{id:"切片集群和-redis-cluster-的联系与区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#切片集群和-redis-cluster-的联系与区别"}},[v._v("#")]),v._v(" 切片集群和 Redis Cluster 的联系与区别")]),v._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),s("p",[s("code",[v._v("Redis Cluster是切片集群的一种实现方案。")])]),v._v(" "),s("p",[v._v("Redis Cluster："),s("code",[v._v("实现切片集群")]),v._v("。")]),v._v(" "),s("p",[v._v("Redis Cluster方案采用"),s("code",[v._v("哈希槽（Hash Slot）")]),v._v("，处理"),s("code",[v._v("数据与实例")]),v._v("之间的"),s("code",[v._v("映射关系")]),v._v("；一个切片集群有"),s("code",[v._v("16384")]),v._v("个哈希槽，哈希槽"),s("code",[v._v("类似于数据分区")]),v._v("，每个键值对都会根据它的key被映射到一个哈希槽中。 映射步骤：根据key按照CRC16计算一个16bit值，再用16bit值对16384取模，每个模数代表一个相应编号的哈希槽")])]),v._v(" "),s("p",[v._v("有5个哈希槽的Redis Cluster示意图")]),v._v(" "),s("p",[s("img",{attrs:{src:"/redis/base/7d070c8b19730b308bfaabbe82c2f1ab.jpg",alt:"img"}})]),v._v(" "),s("p",[v._v("示意图中的切片集群一共有 3 个实例，同时假设有 5 个哈希槽，我们首先可以通过下面的命令手动分配哈希槽：")]),v._v(" "),s("p",[v._v("实例 1 保存哈希槽 0 和 1，实例 2 保存哈希槽 2 和 3，实例 3 保存哈希槽 4。")]),v._v(" "),s("div",{staticClass:"language-css extra-class"},[s("pre",{pre:!0,attrs:{class:"language-css"}},[s("code",[v._v("redis-cli -h 172.16.19.3 –p 6379 cluster addslots 0"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v("1\nredis-cli -h 172.16.19.4 –p 6379 cluster addslots 2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v("3\nredis-cli -h 172.16.19.5 –p 6379 cluster addslots 4\n")])])]),s("p",[s("code",[v._v("注意：")]),v._v("在"),s("code",[v._v("手动分配哈希槽时")]),v._v("，需要把 16384 个槽都分配完，否则 Redis 集群无法正常工作。")]),v._v(" "),s("h3",{attrs:{id:"客户端如何定位数据"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#客户端如何定位数据"}},[v._v("#")]),v._v(" 客户端如何定位数据？")]),v._v(" "),s("h4",{attrs:{id:"哈希槽分布在哪个实例上"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#哈希槽分布在哪个实例上"}},[v._v("#")]),v._v(" 哈希槽分布在哪个实例上?")]),v._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),s("p",[v._v("在定位键值对数据时，它所处的哈希槽是可以通过计算得到的，这个计算可以在客户端发送请求时来执行。但是，要进一步定位到实例，"),s("code",[v._v("还需要知道哈希槽分布在哪个实例上")]),v._v("。")])]),v._v(" "),s("p",[v._v("一般来说，"),s("code",[v._v("客户端和集群实例建立连接后")]),v._v("，实例就会把哈"),s("code",[v._v("希槽的分配信息发给客户端")]),v._v("。但是，在集群刚刚创建的时候，每个实例只知道自己被分配了哪些哈希槽，是不知道其他实例拥有的哈希槽信息的。")]),v._v(" "),s("p",[s("code",[v._v("那么，客户端为什么可以在访问任何一个实例时，都能获得所有的哈希槽信息呢？")])]),v._v(" "),s("p",[v._v("这是因为，Redis 实例会把自己的哈希槽信息"),s("code",[v._v("发给和它相连接的其它实例")]),v._v("，来完成哈希槽"),s("code",[v._v("分配信息的扩散")]),v._v("。当实例之间相互连接后，每个实例就有所有哈希槽的映射关系了。")]),v._v(" "),s("h4",{attrs:{id:"实例和哈希槽的对应关系发生变化怎么办"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实例和哈希槽的对应关系发生变化怎么办"}},[v._v("#")]),v._v(" 实例和哈希槽的对应关系发生变化怎么办")]),v._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),s("p",[v._v("但是，在集群中，实例和哈希槽的对应关系并不是一成不变的，最常见的变化有两个：")]),v._v(" "),s("ul",[s("li",[v._v("在集群中，实例有"),s("code",[v._v("新增")]),v._v("或"),s("code",[v._v("删除")]),v._v("，Redis 需要"),s("code",[v._v("重新分配哈希槽")]),v._v("；")]),v._v(" "),s("li",[v._v("为了"),s("code",[v._v("负载均衡")]),v._v("，Redis 需要把哈希槽在所有实例上重新分布一遍。")])])]),v._v(" "),s("p",[s("code",[v._v("Redis Cluster")]),v._v("方案提供了一种重定向机制,所谓的“"),s("code",[v._v("重定向")]),v._v("”，就是指，客户端给一个实例发送数据读写操作时，这个实例上并没有相应的数据，客户端要再给一个"),s("code",[v._v("新实例")]),v._v("发送操作命令。")]),v._v(" "),s("p",[s("code",[v._v("那客户端又是怎么知道重定向时的新实例的访问地址呢？")])]),v._v(" "),s("p",[v._v("当客户端把一个键值对的操作请求发给一个实例时，如果这个实例上并没有这个键值对映射的哈希槽，那么，这个实例就会给客户端返回下面的 "),s("code",[v._v("MOVED")]),v._v("命令响应结果，这个结果中就包含了新实例的访问地址。")]),v._v(" "),s("div",{staticClass:"language-css extra-class"},[s("pre",{pre:!0,attrs:{class:"language-css"}},[s("code",[v._v("GET "),s("span",{pre:!0,attrs:{class:"token property"}},[v._v("hello")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(":")]),v._v("key\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),v._v("error"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v(" MOVED 13320 172.16.19.5"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(":")]),v._v("6379\n")])])]),s("p",[s("code",[v._v("解释")]),v._v("：客户端请求的键值对所在的哈希槽 13320，实际是在 172.16.19.5 这个实例上。")]),v._v(" "),s("p",[v._v("通过返回的 MOVED 命令，就相当于把哈希槽所在的新实例的信息告诉给客户端了。这样一来，客户端就可以直接和 172.16.19.5 连接，并发送操作请求了。")]),v._v(" "),s("p",[s("img",{attrs:{src:"/redis/base/350abedefcdbc39d6a8a8f1874eb0809.jpg",alt:"img"}})]),v._v(" "),s("p",[s("code",[v._v("注意")]),v._v("：")]),v._v(" "),s("p",[v._v("客户端向实例 2 发送请求，但此时，Slot 2 中的数据只有一部分迁移到了实例 3，还有部分数据没有迁移。在这种迁移部分完成的情况下，客户端就会收到一条 ASK 报错信息")]),v._v(" "),s("div",{staticClass:"language-css extra-class"},[s("pre",{pre:!0,attrs:{class:"language-css"}},[s("code",[v._v("GET "),s("span",{pre:!0,attrs:{class:"token property"}},[v._v("hello")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(":")]),v._v("key\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),v._v("error"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v(" ASK 13320 172.16.19.5"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(":")]),v._v("6379\n")])])]),s("p",[s("code",[v._v("解释")]),v._v("：客户端请求的键值对所在的哈希槽 13320，在 172.16.19.5 这个实例3上，但是这个哈希槽正在迁移。")]),v._v(" "),s("p",[v._v("此时，客户端需要先给 172.16.19.5 这个实例3发送一个 "),s("code",[v._v("ASKING")]),v._v("命令。这个命令的意思是，让这个实例"),s("code",[v._v("允许执行客户端接下来发送的命令")]),v._v("。然后，客户端再向这个实例发送 GET 命令，以读取数据")]),v._v(" "),s("p",[v._v("在下图中，Slot 2 正在从实例 2 往实例 3 迁移，key1 和 key2 已经迁移过去，key3 和 key4 还在实例 2。")]),v._v(" "),s("p",[v._v("客户端向实例 2 请求 key2 后，就会收到实例 2 返回的 ASK 命令。ASK 命令表示两层含义：")]),v._v(" "),s("p",[v._v("第一，表明 Slot 数据还在迁移中；")]),v._v(" "),s("p",[v._v("第二，ASK 命令把客户端所请求数据的"),s("code",[v._v("最新实例地址")]),v._v("返回给客户端，此时，客户端需要给实例 3 发送"),s("code",[v._v("ASKING 命令，然后再发送操作命令")]),v._v("。")]),v._v(" "),s("p",[s("img",{attrs:{src:"/redis/base/e93ae7f4edf30724d58bf68yy714eeb0.jpg",alt:"img"}})]),v._v(" "),s("p",[s("code",[v._v("注意")]),v._v("： 和 "),s("code",[v._v("MOVED")]),v._v(" 命令不同，"),s("code",[v._v("ASK")]),v._v(" 命令并"),s("code",[v._v("不会更新客户端缓存的哈希槽分配信息")]),v._v("。")]),v._v(" "),s("p",[v._v("所以，在上图中，如果客户端再次"),s("code",[v._v("请求 Slot 2")]),v._v(" 中的数据，它"),s("code",[v._v("还是")]),v._v("会给"),s("code",[v._v("实例 2 发送请求")]),v._v("。这也就是说，ASK 命令的作用"),s("code",[v._v("只是让客户端能给新实例发送一次请求")]),v._v("，而"),s("code",[v._v("不像 MOVED")]),v._v(" 命令那样，会"),s("code",[v._v("更改本地缓存")]),v._v("，让")]),v._v(" "),s("p",[v._v("后续所有命令"),s("code",[v._v("都发往新实例")]),v._v("。")]),v._v(" "),s("h3",{attrs:{id:"redis-cluster为什么不采用把key直接映射到实例的方式-而采用哈希槽的方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis-cluster为什么不采用把key直接映射到实例的方式-而采用哈希槽的方式"}},[v._v("#")]),v._v(" Redis Cluster为什么不采用把key直接映射到实例的方式，而采用哈希槽的方式?")]),v._v(" "),s("p",[v._v("1、整个集群存储"),s("code",[v._v("key的数量是无法预估")]),v._v("的，key的"),s("code",[v._v("数量非常多时，")]),v._v("直接记录每个key对应的实例映射关系，这个"),s("code",[v._v("映射表会非常庞大")]),v._v("，这个映射表无论是存储在服务端还是客户端都"),s("code",[v._v("占用了非常大的内存空间")]),v._v("。")]),v._v(" "),s("p",[v._v("2、Redis Cluster采用无中心化的模式（无proxy，客户端与服务端直连），客户端在某个节点访问一个key，如果这个key不在这个节点上，这个节点需要有纠正客户端路由到正确节点的能力（MOVED响应），这就")]),v._v(" "),s("p",[v._v("需要节点之间互相交换路由表，每个节点拥有整个集群完整的路由关系。"),s("code",[v._v("如果存储的都是key与实例的对应关系")]),v._v("，节点之间"),s("code",[v._v("交换信息也会变得非常庞大")]),v._v("，消耗过多的网络资源，而且就算交换完成，相当于每个节点都")]),v._v(" "),s("p",[v._v("需要额外存储其他节点的路由表，内存占用过大造成资源浪费。")]),v._v(" "),s("p",[v._v("3、当集群在扩容、缩容、数据均衡时，节点之间会发生"),s("code",[v._v("数据迁移")]),v._v("，迁移时需要"),s("code",[v._v("修改每个key的映射关系，维护成本高")]),v._v("。")]),v._v(" "),s("p",[v._v("4、而在中间增加一层哈希槽，可以把"),s("code",[v._v("数据和节点解耦")]),v._v("，"),s("code",[v._v("key通过Hash计算，只需要关心映射到了哪个哈希槽")]),v._v("，然后再通过"),s("code",[v._v("哈希槽和节点的映射表找到节点")]),v._v("，相当于消耗了很少的CPU资源，不但让数据分布更均匀，")]),v._v(" "),s("p",[v._v("还可以让这个映射表变得很小，利于客户端和服务端保存，节点之间交换信息时也变得轻量。")])])}),[],!1,null,null,null);_.default=t.exports}}]);